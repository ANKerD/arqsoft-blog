
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>android on Arquitetura de Software</title>
   <link>https://joaoarthurbm.github.io/arqsoft-blog/tags/android/</link>
   <description>Recent content in android on Arquitetura de Software</description>
   <generator>Hugo -- gohugo.io</generator>
   <copyright>Copyright &amp;copy; Turma de Arquitetura de Software UFCG</copyright>
   <lastBuildDate>Tue, 06 Oct 2020 00:00:00 -0300</lastBuildDate>
   
       <atom:link href="https://joaoarthurbm.github.io/arqsoft-blog/tags/android/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>tModLoader</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/tmodloader/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/tmodloader/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jailson Barros.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 119210723&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jailson.junior@ccc.ufcg.edu.br&#34;&gt;jailson.junior@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/tModLoader/tModLoader&#34;&gt;https://github.com/tModLoader/tModLoader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/tModLoader/tModLoader&#34;&gt;tModLoader&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do tModLoader. O foco aqui é a descrição do serviço específico de criação de &lt;em&gt;mods&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-tmodloader&#34;&gt;Descrição Geral sobre o tModLoader&lt;/h2&gt;
&lt;p&gt;O &lt;a href=&#34;https://tmodloader.net/&#34;&gt;tModLoader&lt;/a&gt; é um projeto de modificação e expansão do jogo &lt;a href=&#34;https://terraria.org/&#34;&gt;Terraria&lt;/a&gt;, sendo possivel criar &lt;em&gt;mods&lt;/em&gt; e jogar com esses &lt;em&gt;mods&lt;/em&gt;. tModLoader expande suas aventuras no Terraria com novos conteúdos para explorar criados pela comunidade!. tModLoader permite que os jogadores criem e joguem &lt;em&gt;mods&lt;/em&gt; e é projetado de forma que você possa jogar sozinho ou com amigos, com um &lt;em&gt;mod&lt;/em&gt; ou com vários &lt;em&gt;mods&lt;/em&gt;: escolha jogar como quiser!&lt;/p&gt;
&lt;p&gt;Mais informações sobre o projeto &lt;a href=&#34;https://tmodloader.net/&#34;&gt;nesse link!&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-criação-de-mods&#34;&gt;O Serviço de Criação de Mods&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Auxiliar toda a comunidade do Terraria na criação e publicação de &lt;em&gt;mods&lt;/em&gt;, de forma fácil e rápida.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Pretendemos auxiliar a criação de mods&lt;/p&gt;
&lt;p&gt;Queremos ter acesso ao grau de atividade no twitter de parlamentares e de influenciadores do debate no twitter. Além disso, queremos saber quanto essas pessoas tuítam sobre cada proposição ou tema e a indicadores sobre sua atividade. Para parlamentares também queremos indicadores a partir dos léxicos de discurso desenvolvidos pelos nossos parceiros.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural ORY Oathkeeper</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/oathkeeper/</link>
       <pubDate>Wed, 09 Dec 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/oathkeeper/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Hemillainy Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210802&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:hemillainy.santos@ccc.ufcg.edu.br&#34;&gt;hemillainy.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ory/oathkeeper&#34;&gt;https://github.com/ory/oathkeeper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----ory-oathkeeper&#34;&gt;Descrição Arquitetural &amp;ndash; ORY Oathkeeper&lt;/h1&gt;
&lt;p&gt;Nesse documento será descrita a arquitetura base do projeto &lt;a href=&#34;https://github.com/ory/oathkeeper&#34;&gt;ORY Oathkeeper&lt;/a&gt;, utilizando o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-ory-oathkeeper&#34;&gt;Descrição Geral sobre o ORY Oathkeeper&lt;/h2&gt;
&lt;p&gt;O ORY Oathkeeper é um serviço cuja função é analisar as requisições recebidas pelo servidor a fim de validá-las. Caso a requisição seja válida, ela é encaminhada para o servidor final; caso seja inválida, o fluxo de validações é encerrado e o Oathkeeper retorna uma mensagem de erro para o cliente.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementação de um serviço, altamente configurável, que valida toda requisição que chega no servidor. A partir dessa validação, é possível filtrar requisições inválidas, impedindo assim que elas cheguem ao serviço final. Além disso, é possível também fazer alterações em requisições válidas antes de encaminhá-las.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Permitir que a aplicação possa configurar todas as regras de acesso que serão utilizadas pelo Oathkeeper no pipeline de validação. Essa configuração pode ser feita em dois formatos: JSON e YAML. Segue abaixo exemplos dessa configuração:&lt;/p&gt;
&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;p&gt;JSON&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;id&amp;quot;: &amp;quot;some-id&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;v0.36.0-beta.4&amp;quot;,
    &amp;quot;upstream&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;http://my-backend-service&amp;quot;,
    &amp;quot;preserve_host&amp;quot;: true,
    &amp;quot;strip_path&amp;quot;: &amp;quot;/api/v1&amp;quot;
    },
    &amp;quot;match&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;http://my-app/some-route/&amp;lt;.\*&amp;gt;&amp;quot;,
    &amp;quot;methods&amp;quot;: [&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;]
    },
    &amp;quot;authenticators&amp;quot;: [{ &amp;quot;handler&amp;quot;: &amp;quot;noop&amp;quot; }],
    &amp;quot;authorizer&amp;quot;: { &amp;quot;handler&amp;quot;: &amp;quot;allow&amp;quot; },
    &amp;quot;mutators&amp;quot;: [{ &amp;quot;handler&amp;quot;: &amp;quot;noop&amp;quot; }],
    &amp;quot;errors&amp;quot;: [{ &amp;quot;handler&amp;quot;: &amp;quot;json&amp;quot; }]
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;heading-1&#34;&gt;&lt;/h4&gt;
&lt;p&gt;YAML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id: some-id
version: v0.36.0-beta.4
upstream:
url: http://my-backend-service
preserve_host: true
strip_path: /api/v1
match:
url: http://my-app/some-route/&amp;lt;.\*&amp;gt;
methods: - GET - POST
authenticators:

- handler: noop
  authorizer:
  handler: allow
  mutators:
- handler: noop
  errors:
- handler: json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Para mais detalhes à respeito da configuração, acesse &lt;a href=&#34;https://www.ory.sh/oathkeeper/docs/api-access-rules&#34;&gt;esse link&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Oathkeeper funciona como uma camada intermediária entre o cliente e o servidor, camada esta que é responsável por fazer a validação das requisições, validando desde o formato da URL chamada até a presença ou não de tokens de acesso, escopos, etc. Desse modo, quando o usuário solicita algo ao cliente, ele enviará a requisição para o servidor, porém antes de chegar ao destino final a requisição será tratada pelo Oathkeeper, caso a requisição atenda às regras de acesso definidas no arquivo de configuração ela será encaminhada para o servidor final; se não, o Oathkeeper não fará o encaminhamento e uma mensagem de erro será retornada para o cliente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Devido à sua implementação ser escrita em GO, torna-se bastante fácil sua utilização ou integração com outros sistemas, uma vez que para utilizá-lo basta instalar o binário GO ou executar sua imagem Docker.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para lidar com as requisições, o Oathkeeper implementa o Access Rule Pipeline que é composto pelos quatro componentes descritos a seguir:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication: valida se a requisição contém as credenciais ou tokens necessários.&lt;/li&gt;
&lt;li&gt;Authorization: valida de o usuário possui as permissões necessárias.&lt;/li&gt;
&lt;li&gt;Mutation: altera as credenciais enviadas na requisição para um formato que o servidor entenda; isso permite que o servidor lide apenas com um único tipo de credencial, visto que independente do tipo que for enviado na requisição, o mutator irá transformá-la em um tipo que é compreendido pelo serviço.&lt;/li&gt;
&lt;li&gt;Error handlers: caso ocorra um erro em um dos steps de validação (authentication ou authorization), esse componente define como o erro será apresentado para o cliente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta o fluxo de uma requisição no Oathkeeper.
Ao ser enviada pelo cliente para o servidor, a requisição entrará no pipeline de regras de acesso, onde o primeiro step será a verificação por parte do Authentication. Em seguida, caso validada, ela será verificada pelo Authorization. Conforme mostra o diagrama, caso a verificação falhe em um dos steps anteriores, o Error Handler é acionado e enviará uma resposta de erro para o cliente, mas caso a requisição seja válida ela é enviada para o Mutator, onde poderá sofrer algumas alterações antes de ser encaminhada para o servidor final.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-info.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o GIMP</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/gimp/</link>
       <pubDate>Mon, 07 Dec 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/gimp/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto GIMP.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Mariana Araújo Lucena.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211305&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:mariana.lucena@ccc.ufcg.edu.br&#34;&gt;mariana.lucena@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/GNOME/gimp&#34;&gt;https://github.com/GNOME/gimp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----gnomegimp&#34;&gt;Descrição Arquitetural &amp;ndash; GNOME/gimp&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, e tem como objetivo descrever parte da arquitetura do projeto &lt;a href=&#34;https://github.com/GNOME/gimp&#34;&gt;GNOME/gimp&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do GIMP. O foco aqui é a descrição de um serviço específico de análise do GIMP, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-gimp&#34;&gt;Descrição Geral sobre o GIMP&lt;/h2&gt;
&lt;p&gt;GIMP (acrônimo para GNU Image Manipulation Program) é um programa voltado, essencialmente, para edição e criação de imagens raster e, em menor escala, para desenho vetorial. O software é repleto de recursos, de fácil uso e uma boa alternativa gratuita ao mais conhecido dos editores, o gigante Adobe Photoshop.&lt;/p&gt;
&lt;h2 id=&#34;os-plugins-de-filtros-no-gimp&#34;&gt;Os Plugins de filtros no GIMP&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;As funcionalidades do GIMP pode ser facilmente estendida por meio de plugins. Plugins do GIMP são programas externos que são executados sob o controle da aplicação principal GIMP e interagem com ela muito de perto. Plugins podem manipular imagens de quase todas as formas que os usuários querem.&lt;/p&gt;
&lt;p&gt;Várias dezenas de plugins estão incluídas na distribuição oficial do GIMP e são instaladas automaticamente junto com o programa. A maioria deles pode ser acessada através do menu filtros (na verdade, tudo nesse menu é um plugin ou um script), mas vários deles estão localizados em outros menus. Em muitos casos, você pode usar um sem nunca perceber que é um plugin: por exemplo, a função &amp;ldquo;Normalizar&amp;rdquo; para correção automática de cores é na verdade um plugin, embora não há nada na maneira como ela funciona que iria demonstrar isso.&lt;/p&gt;
&lt;p&gt;Os filtros permitem fazer efeitos complexos com poucos cliques, efeitos como de iluminação, distorção, entre outros. No menu “Filtros”, você tem acesso a mais de 140 tipos de filtros diferentes. Os filtros são divididos em 15 categorias para que você consiga achá-los mais facilmente. Essas categorias são: desfocar, realces, distorções, efeitos de sombra, efeitos de luz, ruído detectar borda, genéricos, combinar, filtros artísticos, mapear, renderizar, web, animação, alfa para logo, decoração.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;É necessário executar o download do instalador do GIMP e abrir o arquivo de instalação. Depois da instalação, pode começar a usá-lo. Para a aplicação de filtros em uma imagem, é necessário fazer o upload da mesma para o programa, no menu superior selecionar a janela &amp;ldquo;Filtros&amp;rdquo; e, logo após, escolher o filtro.&lt;/p&gt;
&lt;p&gt;Para adicionar um plugin de um novo filtro na interface do GIMP é necessário instalar o plugin, descompactá-lo, entrar na pasta do efeito e copiar todos os arquivos .py. Logo após, é necessário acessar a pasta de plugins do GIMP e colar os arquivos .py selecionados anteriormente. Reinicie o programa e o novo filtro já poderá ser visto na aba &amp;ldquo;Filtros&amp;rdquo; do menu.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;center&#34; border=&#34;15px&#34; src=&#34;https://github.com/marianaalucena/mini-projeto/blob/main/imagens/contexto1.jpg?raw=true&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Script-Fu é uma linguagem para escrever scripts, que permite que você execute uma série de comandos do GIMP automaticamente.&lt;/p&gt;
&lt;p&gt;Python-Fu é um conjunto de módulos Python que funcionam como um conteúdo adicional para libgimp, permitindo a escrita de plug-ins para o GIMP.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;center&#34; border=&#34;15px&#34; src=&#34;https://github.com/marianaalucena/mini-projeto/blob/main/imagens/containers.jpg?raw=true&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O GIMP foi projetado para ser extensível com scripts e plug-ins. Esses dois são tecnicamente diferentes, os scripts estão em Script-Fu e são interpretados pelo interpretador de script integrado. Plugins são processos independentes escritos em potencialmente qualquer idioma. Por muito tempo isso significou apenas C, mas desde o 2.6 também existe uma interface para Python. Mas, para complicar as coisas, a maioria dos &amp;ldquo;plug-ins&amp;rdquo; python são escritos como scripts: eles são principalmente colados entre as chamadas para a API do Gimp, como as de script-fu, então você ouvirá sobre scripts Python (mas eles são realmente plug-ins).&lt;/p&gt;
&lt;h4 id=&#34;script-fu&#34;&gt;Script-Fu&lt;/h4&gt;
&lt;p&gt;Script-Fu é o que o alguns aplicativos chamam de &amp;ldquo;macros&amp;rdquo;. Script-Fu é baseado em uma linguagem interpretada chamada Scheme, e funciona usando funções do banco de procedimentos do GIMP. É possível fazer todos os tipos de coisas com Script-Fu, mas um usuário comum do GIMP provavelmente irá usá-lo para automatizar as coisas que: faz com frequência e/ou são muito complicadas de fazer, e difíceis de lembrar.&lt;/p&gt;
&lt;p&gt;Existem muitos scripts que vêm com o GIMP por padrão, mas existem também grandes quantidades de scripts que estão disponíveis para download em toda Internet.&lt;/p&gt;
&lt;p&gt;Se você tiver baixado um script, copie ou mova o para seu diretório de scripts. Ele pode ser encontrado em Preferências: Pastas → Scripts.&lt;/p&gt;
&lt;p&gt;Faça uma atualização usando filtros → Script-Fu → Atualizar Scripts no menu imagem. O script agora vai aparecer em um dos seus menus. Se você não encontrá-lo, procurar nos filtros no menu de arquivos raiz. Se ele não aparecer em lugar nenhum, algo estava errado com o script e ele não funcionou. (por exemplo, contém erros de sintaxe).&lt;/p&gt;
&lt;h4 id=&#34;python-fu&#34;&gt;Python-Fu&lt;/h4&gt;
&lt;p&gt;Gimp-Python é uma extensão de script para Gimp, semelhante ao Script-Fu. A principal diferença está no que é chamado primeiro. No Script-Fu, o plugin script-fu executa o script, enquanto no Gimp-Python o script está no controle. Outro ponto de diferença entre o Gimp-Python e o Script-Fu é que o Gimp-Python armazena imagens, camadas, canais e outros tipos como objetos em vez de apenas armazenar seus IDs. Isso permite uma melhor verificação de tipo que está faltando no Script-Fu e permite que esses tipos atuem como objetos, completos com atributos e métodos.&lt;/p&gt;
&lt;p&gt;Além disso, o Gimp-Python não se limita apenas a chamar procedimentos do PDB. Ele também implementa o resto do libgimp , incluindo blocos e regiões de pixel, e acesso a outras funções de nível inferior.&lt;/p&gt;
&lt;p&gt;Existe um módulo python chamado plugin.py que define uma estrutura para plug-ins e implementa algumas coisas que eram muito difíceis ou impossíveis de fazer em C.&lt;/p&gt;
&lt;p&gt;O principal objetivo do plugin.py é implementar uma estrutura orientada a objetos para plug-ins. Além disso, ele lida com tracebacks, que de outra forma são ignorados por libgimp, e fornece um método para chamar outros plug-ins Gimp-Python sem passar pelo banco de dados procedural.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O Arquivo é primeiramente selecionado pelo usuário para realização de upload no programa, em seguida é necessário selecionar o filtro desejado, aplicá-lo na imagem, a partir dai tem-se duas opções: salvar e fechar o arquivo ou reverter ao original.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;center&#34; border=&#34;15px&#34; src=&#34;https://github.com/marianaalucena/mini-projeto/blob/main/imagens/infoFiltro.jpg?raw=true&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Até o presente momento ainda não foi aberto nenhum pull request desta documentação para o repositório de docs do GNOME/GIMP.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Inkscape</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/inkscape/</link>
       <pubDate>Tue, 13 Oct 2020 20:00:32 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/inkscape/</guid>
       <description>&lt;h3 id=&#34;autores&#34;&gt;Autores&lt;/h3&gt;
&lt;p&gt;Este documento foi produzido por Gustavo Alves.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Matrícula: 117110919&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contato: &lt;a href=&#34;mailto:gustavo.daniel.alves@ccc.ufcg.edu.br&#34;&gt;gustavo.daniel.alves@ccc.ufcg.edu.br&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Projeto documentado: &lt;a href=&#34;https://gitlab.com/inkscape/inkscape&#34;&gt;https://gitlab.com/inkscape/inkscape&lt;/a&gt; | &lt;a href=&#34;https://gitlab.com/inkscape/extensions&#34;&gt;https://gitlab.com/inkscape/extensions&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural--inkex-api&#34;&gt;Descrição Arquitetural – InkEx API&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto Inkscape. Essa descrição foi baseada principalmente no modelo C4.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será escrita toda a arquitetura do Inkscape. O foco principal é descrever a InkEx, API que permite a criação e utilização de extensões no programa.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-inkscape&#34;&gt;Descrição geral sobre o Inkscape&lt;/h2&gt;
&lt;p&gt;O Inkscape se define como um editor de gráficos vetoriais open source. O programa funciona de forma similar a aplicativos famosos como Adobe Illustrator e Corel Draw, com a diferença de utilizar como forma nativa o padrão aberto SVG (Scalable Vector Graphics).&lt;/p&gt;
&lt;h2 id=&#34;a-inkex&#34;&gt;A InkEx&lt;/h2&gt;
&lt;h4 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h4&gt;
&lt;p&gt;Permitir a extensão por parte dos usuários das funcionalidades do Inkscape a partir de uma API.&lt;/p&gt;
&lt;h4 id=&#34;objetivo-específico&#34;&gt;Objetivo específico&lt;/h4&gt;
&lt;p&gt;Expor uma API que permita que os usuários adicionem funcionalidades ao Inkscape sem necessitar conhecer C++ e GTK, porém apenas Python e XML, tornando-a mais acessível e sem necessidade de compilação prévia.&lt;/p&gt;
&lt;h4 id=&#34;contexto&#34;&gt;Contexto&lt;/h4&gt;
&lt;img src=&#34;Diagrama de contexto.svg&#34; class=&#34;center&#34; style=&#34;height: 700px;&#34;&gt;
&lt;p&gt;Por padrão o Inkscape dá suporte a diferentes fluxos de trabalho, desde a sua utilização para a criação de novos vetores como para o processamento dos já pré-existentes. Apesar disto, é sempre interessante permitir que o usuário expanda as funcionalidades do software aumentando a sua produtividade ou abrindo um novo leque de possibilidades de criação.&lt;/p&gt;
&lt;p&gt;Para isto, o Inkscape fornece uma API que permite integrar scripts de funcionalidade ao fluxo de trabalho do programa.&lt;/p&gt;
&lt;h4 id=&#34;containers&#34;&gt;Containers&lt;/h4&gt;
&lt;img src=&#34;Diagrama de contêineres.svg&#34; class=&#34;center&#34;&gt;
&lt;p&gt;As extensões do Inkscape são acessados pelo próprio Inkscape, sendo expostas a partir dos front-ends disponíveis (GUI e CLI). Ao aplicar a funcionalidade de uma extensão, o back-end envia o SVG para a extensão que deverá processá-la e retornar o SVG modificado para o back-end.&lt;/p&gt;
&lt;h4 id=&#34;componentes&#34;&gt;Componentes&lt;/h4&gt;
&lt;img src=&#34;Diagrama de componentes.svg&#34; class=&#34;center&#34;&gt;
&lt;p&gt;As extensões do Inkscape são compostas de dois componentes:&lt;/p&gt;
&lt;h5 id=&#34;descritores&#34;&gt;Descritores&lt;/h5&gt;
&lt;p&gt;Os descritores são arquivos Inkscape XML (.inx) que fornecem informações ao Inkscape referentes aos parâmetros, interface, strings para tradução, configuração e identificação da extensão.&lt;/p&gt;
&lt;h5 id=&#34;scripts&#34;&gt;Scripts&lt;/h5&gt;
&lt;p&gt;Os scripts são os arquivos Python que serão utilizados para realizar o processamento dos arquivos. Eles recebem o SVG a partir de um caminho ou pela entrada padrão. Após finalizar os processamento do arquivo, os scripts podem tanto salvar o arquivo modificado ou reenviá-lo ao Inkscape pela saída padrão. Apesar de não aconselhável, os scripts podem chamar o Inkscape da mesma forma para realizar alguma operação específica.&lt;/p&gt;
&lt;h4 id=&#34;implementação&#34;&gt;Implementação&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;informação&#34;&gt;Informação&lt;/h4&gt;
&lt;p&gt;O fluxo e estados da informação são bastante simples. O SVG é recebido via arquivo ou entrada padrão, é feito uma cópia que se processada corretamente é escrita no arquivo ou na saída padrão.&lt;/p&gt;
&lt;img src=&#34;Visão de informação.png&#34; class=&#34;center&#34;&gt;
&lt;h3 id=&#34;contribuições-concretas&#34;&gt;Contribuições concretas&lt;/h3&gt;
</description>
     </item>
   
     <item>
       <title>Arquitetura do Jitsi Meet</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/jitsi-meet/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/jitsi-meet/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Daniele Aparecida de Melo Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110348&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:daniele.silva@ccc.ufcg.edu.br&#34;&gt;daniele.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/jitsi/jitsi-meet&#34;&gt;https://github.com/jitsi/jitsi-meet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-gravação-de-uma-conferência&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de gravação de uma conferência&lt;/h1&gt;
&lt;p&gt;Neste documento, é descrito um serviço específico de gravaçãode uma conferenência do projeto &lt;a href=&#34;https://github.com/jitsi/jitsi-meet&#34;&gt;Jitsi Meet&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-o-jitsi-meet&#34;&gt;Sobre o Jitsi Meet&lt;/h2&gt;
&lt;p&gt;O Jitsi Meet é uma solução de videoconferência totalmente criptografada e de código aberto disponível todos os dias gratuitamente. O Jitsi Meet é executado no navegador, sem necessidade de criar uma conta ou de instalação.&lt;/p&gt;
&lt;p&gt;O Jitsi Meet permite uma colaboração muito eficiente. Os usuários podem transmitir sua área de trabalho ou apenas algumas janelas. Ele também suporta edição de documentos compartilhados com Etherpad. O site oficial é: &lt;a href=&#34;https://meet.jit.si&#34;&gt;https://meet.jit.si&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-o-serviço-de-gravação-de-uma-conferência&#34;&gt;Sobre o serviço de gravação de uma conferência&lt;/h2&gt;
&lt;p&gt;O objetivo desse serviço é capturar áudio e vídeo de uma conferência e salvar localmente.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto de gravação de uma conferência compreende os seguintes sistemas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jitsi Meet — aplicação JavaScript que usa o Jitsi Videobridge para fornecer videoconferências ​​de alta qualidade, seguras e escaláveis.&lt;/li&gt;
&lt;li&gt;Jitsi Conference Focus (Jicofo) — componente server-side usado nas conferências do Jitsi Meet para gerenciar as sessões de mídia entre cada um dos participantes e o Videobridge.&lt;/li&gt;
&lt;li&gt;Jibri — conjunto de ferramentas para gravar e/ou transmitir uma conferência do Jitsi Meet.&lt;/li&gt;
&lt;li&gt;Prosody — servidor externo XMPP (abreviação para &lt;em&gt;Extensible Messaging and Presence Protocol&lt;/em&gt;) usado para sinalização.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No seguinte diagrama de contexto para o serviço de gravação, o processo começa quando o usuário clica em &amp;ldquo;Iniciar gravação&amp;rdquo;. O frontend do Jitsi Meet captura esse evento e o servidor envia uma requisição para o Prosody em formato XMPP, para que este encaminhe a mensagem ao Jicofo. O Jitsi Meet possui uma instância da conferência criada pelo Jicofo — responsável por todo o gerenciamento de uma conferência —, mas a comunicação entre eles é via XMPP.&lt;/p&gt;
&lt;p&gt;Jicofo recebe um token e o formato do arquivo de gravação (&amp;lsquo;ogg&amp;rsquo;, &amp;lsquo;flac&amp;rsquo; ou &amp;lsquo;wav&amp;rsquo;) e utiliza o Jibri para lidar com a gravação. O Jibri é notificado que a gravação deve ser iniciada e entra como participante para gravar a conferência. Então, informa ao Jicofo seu novo status.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O Jitsi Meet é composto de quatro containers: aplicação client-side escrita em React; aplicação móvel implementada com React Native; um servidor Nginx; e um banco de dados SQL.&lt;/p&gt;
&lt;p&gt;As aplicações se comunicam com o servidor via HTTPS. O Nginx conversa com o Prosody atráves de mensagens XMPP, para então ser encaminhadas ao Jicofo. Jicofo e Jibri são escritos na linguagem Java.&lt;/p&gt;
&lt;p&gt;Abaixo se encontra o diagrama de containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No Jitsi Meet, existem três componentes principais para o processo de gravação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RecordingController, que lida com a sinalização entre os participantes e serve de fachada para outros componentes.&lt;/li&gt;
&lt;li&gt;RecordingAdapter, que engloba a API de áudio da Web e diferentes codecs de áudio. Possui uma interface que facilita alternar entre diferentes formatos e serve como um ponto para futuras extensões.&lt;/li&gt;
&lt;li&gt;SessionManager, que gerencia e mantém as informações sobre cada segmento da gravação. Essas informações são usadas para restauração de travamento e concatenação de segmentos da gravação.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As gravações são mantidas no armazenamento local do navegador (local storage) de cada participante, que não possui uma cota. Um codec com espaço eficiente diminui o risco de perda de gravações devido ao espaço.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de componentes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como mencionado, o Jibri entra na conferência como um participante e, em seguida, captura vários fluxos de áudio/vídeo e os envia para arquivos locais.&lt;/p&gt;
&lt;p&gt;Em termos gerais, as etapas para gravar uma conferência são:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Criar uma sessão com a conferência JitsiMeet;&lt;/li&gt;
&lt;li&gt;Receber fluxos de áudio/vídeo;&lt;/li&gt;
&lt;li&gt;Receber fluxos de mídia;&lt;/li&gt;
&lt;li&gt;Gravar fluxos de áudio/vídeo;&lt;/li&gt;
&lt;li&gt;Gravar streams de mídia;&lt;/li&gt;
&lt;li&gt;Registrar metadados.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Os metadados são mensagens legíveis por humanos que descrevem todo o procedimento de gravação, por exemplo: gravação iniciada, gravação finalizada e alto-falante alterado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Descrição arquitetural do Zulip</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/zulip/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/zulip/</guid>
       <description>&lt;hr&gt;
&lt;img src=&#34;./logo.png&#34; style=&#34;width:75%; display: flex; margin: 0 auto&#34;/&gt;
Zulip é uma ferramenta de chat em grupo open-source que combina a eficiência de um chat em tempo real com a produtividade de conversas em thread.
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Maurício Alves Valverde Carvalho.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211593&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.carvalho@ccc.ufcg.edu.br&#34;&gt;joao.carvalho@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/zulip/zulip&#34;&gt;https://github.com/zulip/zulip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/zulip/zulip&#34;&gt;Zulip&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;Zulip é um aplicativo de chat em grupo. O zulip combina o imediatismo de um chat em tempo real com a organização e produtividade de um modelo de threads baseado nos emails. Mais informações sobre o produto podem ser encontradas &lt;a href=&#34;https://zulip.com&#34;&gt;nest link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-zulip&#34;&gt;O zulip&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço de chat em tempo real em grupo para uma ampla gama de organizações e equipes. De empresas a projetos voluntários.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Um servidor pode hospedar múltiplos realms (organizações) Zulip, cada um no seu domínio. Cada realm é uma instância única com os seus próprios usuários, streams, customizações e etc.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de contexto, podemos ver que o Zulip consiste de uma aplicação backend, um banco de dados e aplicações cliente. Essas aplicações cliente fazem requisições por meio do protocolo HTTPS para a API do Zulip Server, que por sua vez se comunica com o banco de dados, atualizando mensagens, threads, canais, entre outros. Além disso, o Zulip fornece um módulo que implementa autenticação por meio de diversas aplicações de terceiros, como o Github, Google account e Facebook.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;clients&#34;&gt;Clients&lt;/h4&gt;
&lt;p&gt;Aplicações que rodam no lado do cliente, e são responsáveis por prover a interação do cliente com uma determinada instância de servidor Zulip por meio de requisições HTTPS e também via web socket para eventos. São fornecidas funcionalidades como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Listagem de canais&lt;/li&gt;
&lt;li&gt;Listagem de threads&lt;/li&gt;
&lt;li&gt;Listagem de usuários&lt;/li&gt;
&lt;li&gt;Painel de configuração do realm&lt;/li&gt;
&lt;li&gt;Caixa para composição de mensagem&lt;/li&gt;
&lt;li&gt;Funcionalidade de criação de canais/threads&lt;/li&gt;
&lt;li&gt;Espaço de leitura de mensagens&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;zulip-web&#34;&gt;Zulip Web&lt;/h5&gt;
&lt;p&gt;Principal aplicação cliente, roda no domínio específico da organização (ex: chat.zulip.org).&lt;/p&gt;
&lt;h5 id=&#34;zulip-terminal&#34;&gt;Zulip Terminal&lt;/h5&gt;
&lt;p&gt;Permite rodar uma versão simplificada do Zulip diretamente do terminal do usuário.&lt;/p&gt;
&lt;h5 id=&#34;zulip-mobile&#34;&gt;Zulip Mobile&lt;/h5&gt;
&lt;p&gt;Aplicação mobile escrita em React Native que permite utilização do Zulip nas plataformas Android e iOS.&lt;/p&gt;
&lt;h5 id=&#34;zulip-desktop&#34;&gt;Zulip Desktop&lt;/h5&gt;
&lt;p&gt;Aplicação escrita com o framework Electron que permite rodar o zulip diretamente na máquina, sem necessidade de utilizar o browser.&lt;/p&gt;
&lt;h4 id=&#34;zulip-server&#34;&gt;Zulip Server&lt;/h4&gt;
&lt;p&gt;Aplicação escrita em Python, utilizando o framework Django que implementa praticamente toda lógica de negócios do Zulip. Serve aplicações client com o conteúdo das mensagens/canais via requisições HTTPS e também atualiza o banco de dados via queries SQL.&lt;/p&gt;
&lt;h4 id=&#34;os-endpoints-são-divididos-nas-seguintes-entidades&#34;&gt;Os endpoints são divididos nas seguintes entidades:&lt;/h4&gt;
&lt;h5 id=&#34;messages&#34;&gt;Messages&lt;/h5&gt;
&lt;p&gt;Entidade que representa uma mensagem. Mensagens podem ser enviadas, editadas, podem ter anexos, emojis customizados. Existem também endpoints para pegar o histórico de edição de uma mensagem.&lt;/p&gt;
&lt;h5 id=&#34;streams&#34;&gt;Streams&lt;/h5&gt;
&lt;p&gt;Entidade que representa uma stream (canal). Um usuário pode se inscrever num canal, criar, deletar, criar tópicos.&lt;/p&gt;
&lt;h5 id=&#34;users&#34;&gt;Users&lt;/h5&gt;
&lt;p&gt;Entidade que representa um usuário&lt;/p&gt;
&lt;h5 id=&#34;server--organização&#34;&gt;Server &amp;amp; Organização&lt;/h5&gt;
&lt;p&gt;Entidade que representa uma organização que hospeda um servidor Zulip&lt;/p&gt;
&lt;h4 id=&#34;módulo-de-autenticação&#34;&gt;Módulo de autenticação&lt;/h4&gt;
&lt;p&gt;Módulo responsável por autenticar um usuário a aplicação. Além de prover sua própria implementação, ele também disponibiliza integração com diversas aplicações de terceiros para que seja possível configurar 3rd party authentication.&lt;/p&gt;
&lt;h4 id=&#34;banco-de-dados&#34;&gt;Banco de dados&lt;/h4&gt;
&lt;p&gt;Responsável por persistir os dados&lt;/p&gt;
&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;
&lt;p&gt;Nesta seção, focarei nos componentes do Zulip Server.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;nginx&#34;&gt;Nginx&lt;/h4&gt;
&lt;p&gt;Front-end do servidor. Recebe todo o tráfego da parte do cliente, repassando para o Tornado/Django e vice-versa. Ele lida com solicitações HTTP de acordo com as regras estabelecidas nos vários arquivos de configuração encontrados em zulip/puppet/zulip/files/nginx/.&lt;/p&gt;
&lt;h4 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h4&gt;
&lt;p&gt;PostgreSQL (também conhecido como Postgres) é o banco de dados que armazena todos os dados persistentes, ou seja, dados que devem viver além da sessão atual do usuário.&lt;/p&gt;
&lt;h4 id=&#34;django&#34;&gt;Django&lt;/h4&gt;
&lt;p&gt;É a principal aplicação server. Implementa toda a lógica de negócios do Zulip na parte do servidor, lidando com todas as rotas, exceto a de eventos.&lt;/p&gt;
&lt;h4 id=&#34;tornado&#34;&gt;Tornado&lt;/h4&gt;
&lt;p&gt;O Tornado é um servidor assíncrono e destina-se especificamente a manter abertas dezenas de milhares de conexões de longa duração - ou seja, rotas que mantêm uma conexão persistente de cada cliente em execução. Por este motivo, é responsável pela entrega do evento nova mensagem, mas não muito mais.&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Aqui vamos focar na entidade mensagem. Embora enviar uma mensagem em um produto de bate-papo possa parecer simples, há muita complexidade necessária para fazer uma experiência de qualidade profissional.&lt;/p&gt;
&lt;h4 id=&#34;lista-de-mensagens---frontend&#34;&gt;Lista de mensagens - Frontend&lt;/h4&gt;
&lt;p&gt;Uma lista de mensagens é o nome dado para o conceito de feed de mensagens no front-end. Existem 3 principais estruturas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma &lt;em&gt;message_list_data&lt;/em&gt; tem apenas os dados de sequenciamento de quais IDs de mensagem vão em que ordem.&lt;/li&gt;
&lt;li&gt;Uma &lt;em&gt;message_list&lt;/em&gt; é construída em cima de message_list_data e contém, adicionalmente, os dados para uma lista de mensagens visíveis para o usuário.&lt;/li&gt;
&lt;li&gt;Uma &lt;em&gt;message_list_view&lt;/em&gt; é construída sobre message_list e contém adicionalmente detalhes de renderização como por exemplo uma janela de até 400 mensagens que está presente no DOM no momento, controles de posição de rolagem, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;implementação-backend&#34;&gt;Implementação backend&lt;/h4&gt;
&lt;p&gt;O fluxo de uso para enviar uma mensagem segue o seguinte fluxo no backend:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;event_queue: Envia emails e notificações mobiele para usuários que precisam receber notificação desta mensagem (ex: usúario marcado no corpo da mensagem)&lt;/li&gt;
&lt;li&gt;check_message: Verifica se o input é uma mensagem válida&lt;/li&gt;
&lt;li&gt;do_send_message: Rotina que de fato envia uma mensagem. Salva o objecto no banco de dados e envia um evento de Mensagem para o subsitema de eventos&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Realizei algumas contribuições no Zulip, segue a lista:&lt;/p&gt;
&lt;h2 id=&#34;contribuições-já-aceitas&#34;&gt;Contribuições já aceitas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/15149&#34;&gt;stream_color.js: Fix color picker not saving custom color.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/14970&#34;&gt;compose.js: Fix compose box didn&amp;rsquo;t collapse.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/13463&#34;&gt;stream settings: Fixing a bug where the stream-list in the stream settings would list all streams but wold show the &amp;lsquo;Subscribed&amp;rsquo; label enabled by resetting the control variable when setting up the page.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/13178&#34;&gt;Settings: Change username to &lt;code&gt;bot email&lt;/code&gt; in bot settings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contribuições-em-aberto&#34;&gt;Contribuições em aberto&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/13459&#34;&gt;typeahead: Allows typeahead to work with &amp;ldquo;intersection&amp;rdquo; logic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/16061&#34;&gt;compose_area: Highlight excessive message length instead of cutting it off&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/15160&#34;&gt;Allow search for messages that have reactions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/15088&#34;&gt;composebox_typeahead: Autocomplete for &amp;lsquo;#&amp;rsquo; should also suggest topics.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Leggo Painel</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/leggo/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/leggo/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Lucas Galvão Menezes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116110464&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.menezes@ccc.ufcg.edu.br&#34;&gt;joao.menezes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/parlametria/leggo-painel&#34;&gt;https://github.com/parlametria/leggo-painel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----site-leggo-painel&#34;&gt;Descrição Arquitetural &amp;ndash; Site Leggo Painel&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/parlametria/leggo-painel&#34;&gt;Leggo Painel&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do Leggo. O foco aqui é a descrição da página específica de análise de atividade parlamentar, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-leggo&#34;&gt;Descrição Geral sobre o Leggo&lt;/h2&gt;
&lt;p&gt;O leggo é um projeto que tem como objetivo permitir o acompanhamento das atividades realizadas por cada deputado e senador no congresso, quais as suas principais áreas de atuação e sua relevância, a partir de ações feitas, dentro do congresso.&lt;/p&gt;
&lt;h2 id=&#34;a-página-leggo-painel&#34;&gt;A página Leggo Painel&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para permitir a fácil visualização das atividades de cada parlamentar no Congresso.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos mostrar a atividade dos parlamentares através de seus documentos apresentados na Câmara ou Senado. Fazemos isso com contagens e avaliações dos pesos de participação que o parlamentar teve em cada documento, sendo esses autorias, emendas, proposições, apensamentos ou requisições. Mostramos também ordenações dos mais ativos em documentos, em redes social e por peso político.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Leggo Painel recebe os dados de um outro serviço de coleta de dados do Congresso, o &lt;a href=&#34;https://github.com/analytics-ufcg/rcongresso&#34;&gt;r-congresso&lt;/a&gt;, e também direto da API do Congresso e pré-processa todos os dados antes de armazena-los. Nosso back-end prepara rotas e reorganiza os dados de acordo com o necessário para o uso.Com os dados adequados, produzimos as visualizações para que o usuário final consiga ler as informações passadas com naturalidade.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Temos quatro containers para abordar aqui.
O container que faz obtenção dos dados, a partir da API externa do Congresso e da biblioteca r-congresso, é implementado em R e faz um pré-processamento dos dados para serem armazenados. Esse container funciona via docker em máquina virtual do LSD;
O container de armazenamento de dados é implementado em postgres, implatado em um heroku próprio, e serve os dados ao back-end;
O container do back-end, também implantado em heroku separado, é implementado em Django e cria as rotas que vão servir o front-end da aplicação, expondo a API e modelando ainda mais os dados;
O container do front-end, que se encontra implantado no heroku próprio para ele, é implementado em Angular e faz requisições HTTP através de seus services para consumir as rotas da API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Temos dois componentes na parte dos dados, o fetcher e o transformador. O fetcher realiza a captura dos dados dos parlamentares da câmara e senado através das API&amp;rsquo;s externas e direciona para o transformador, onde os dados são analisados e pré-processados para seguirem para o armazenamento no banco de dados.
No back-end temos mais três componentes, models, views e controllers (segunido modelo MVC). O controller é o responsável por receber as requisições do front-end e se comunicar com o model apresentando a demanda. O model responde ao controller com os dados necessários para responder a demanda e o controller envia os dados para a view. Na view acontece a formatação dos dados para o modelo e tipo aguardado na resposta da requisição.
E no front-end, temos dois grandes componentes, os services e os components. Os components são de fato onde as funcionalidades do site são implementadas (filtragem de parlamentares, ordenações, criação de visualizações, normalizador de atividades, entre outras) e também o responsável por receber da interface da aplicação (site) as requisições. Já os services são a camada de contato entre front-end e back-end, ela que faz as requisições necessárias para a API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-componente.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O Leggo Painel começa a obtenção de seus dados a partir de API&amp;rsquo;s externas. O Congresso, por exemplo, disponibiliza todas as ações, oficializadas através de um documento, de um parlamentar. Capturamos essas informações, em XML, e tratamos, para que facilite a usabilidade mais adiante no sistema, criando ID&amp;rsquo;s únicos para os parlamentares, por exemplo. Com os dados armazenados já de maneira organizada e coesa, o sistema consegue utilizar esses para suas diversas requisições e funcionalidades. Por exemplo, exibir para cada parlamentar uma badge mostrando quantos documentos autorais ele possui.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-info.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o OsmAnd</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/osmand/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/osmand/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do OsmAnd&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Débora Ferreira de Barros.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116211210&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:debora.barros@ccc.ufcg.edu.br&#34;&gt;debora.barros@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/osmandapp/OsmAnd&#34;&gt;https://github.com/osmandapp/OsmAnd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----mapas-e-rotas-de-navegação-do-osmand&#34;&gt;Descrição Arquitetural &amp;ndash; Mapas e rotas de navegação do OsmAnd&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/osmandapp/OsmAnd&#34;&gt;OsmAnd&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do OsmAnd. O foco é a descrição do serviço que fornece mapas e rotas de navegação do OsmAnd, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-osmand&#34;&gt;Descrição Geral sobre o Osmand&lt;/h2&gt;
&lt;p&gt;OsmAnd (OSM Automated Navigation Directions) é um projeto que tem como objetivo permitir a visualização de mapas bem como oferecer rotas de navegação para carros, bicicletas, transportes públicos e pedestres a partir do uso de dispositivos móveis de forma online e offline. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://osmand.net/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-mapas-de-navegação-do-osmand&#34;&gt;O Serviço de mapas de navegação do OsmAnd&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que oferece mapas e rotas de navegação disponíveis para diversos tipos de transporte e para pedestres.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Utilizando-se de um serviço de mapeamento é desejado criar rotas de navegação que guiem os usuários pelo mapa para o destino escolhido a partir de sua localização atual e disponibilizar mapas que funcionem de forma online e offline.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;A partir de um dispositivo móvel o usuário do OsmAnd consegue visualizar mapas de lugares específicos e traçar rotas de navegação. O OsmAnd por sua vez se utiliza do mapeamento de lugares feitos pelo OpenStreetMap, que é um projeto colaborativo que cria mapas livres e editáveis do mundo com dados abertos, para fornecer a visualização de mapas e rotas.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;osmand-context.jpg&#34; style=&#34;width:25%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O meio de acesso ao OsmAnd é feito exclusivamente a partir de um aplicativo móvel que acessa todas as suas funcionalidades. O aplicativo móvel se utiliza de uma API que faz chamadas XML/HTTPS  para a API da aplicação que por sua vez faz uso dos dados dos mapas oferecidos pelo OpenStreetMap utilizando-se de chamadas de API XML/HTTPS. Todas as informações necessárias são armazenadas em um banco de dados SQLite.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;osmand-container.jpg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O Connection Service tem todos os métodos necessários para fazer a comunicação entre os os dados armazenados e a aplicação. Para isso ele faz chamadas ao Maps Component que por sua vez é o responsável por requisitar dados, estes que são obtidos no OpenStreetMap ou que são passadas pelo Data Component. O Data Component é responsável por manipular o armazenamento, exclusão e modificação de todos os dados no banco de dados da aplicação. Em sua maioria as informações manipuladas são do tipo XML e seguem protocolos do tipo HTTPS.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;osmand-componentes.jpg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Os principais dados manipulados, armazenados, distribuídos e coletados são arquivos do tipo GPX que usam um esquema XML para transferir dados GPS entre aplicações. Eles são usados para descrever rotas, trilhas ou pontos de passagem em mapas.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;GPX-maquina-de-estados.jpg&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Adicionando diagramas: Enviado para análise&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/osmandapp/OsmAnd/pull/10019&#34;&gt;Link&lt;/a&gt; do Pull Request.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o TEAMMATES</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/teammates/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/teammates/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jonas Gomes Aguiar.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115210390&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jonas.aguiar@ccc.ufcg.edu.br&#34;&gt;jonas.aguiar@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/TEAMMATES&#34;&gt;https://github.com/TEAMMATES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----teammates&#34;&gt;Descrição Arquitetural &amp;ndash; TEAMMATES&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/TEAMMATES&#34;&gt;TEAMMATES&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-teammates&#34;&gt;Descrição Geral sobre o TEAMMATES&lt;/h2&gt;
&lt;p&gt;O TEAMMATES é um projeto que tem como objetivo &amp;ldquo;gerenciar avaliações de alunos de um mesmo grupo e outros caminhos de feedback de seus alunos. É fornecido como um serviço baseado em nuvem para educadores e alunos.&amp;rdquo; Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://teammatesv4.appspot.com/web/front/home&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;teammates&#34;&gt;TEAMMATES&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para realização de avaliação e feedback entre pares, e professores.&lt;/p&gt;
&lt;p&gt;Buscamos ter meios flexiveis de feedback, usufruindo de controle de visibilidade para tal, gerando relatórios e estatisticas, com um controle de acesso refinado. Na geração de avaliação, buscamos disponibilizar diferentes tipos delas, podendo conjunto serem reutilizados. Os alunos poderam ter acesso as atividades e feedbacks via email sem necessitar acessar diretamente a plataforma.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;contexto.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O sistema da aplicação do TEAMMATES é utilizado por usuários de dois tipos: Student e Instructor. Eles interagem com o sistema atráves de uma SPA, ou atráves do serviço de email do google. Tem como principais agentes relacionados os usuários, o próprio sistema TEAMMATES e o serviço de email.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;container.jpg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;O SPA é a porta principal de acesso com os usários, a comunicação do SPA com o container Backend é feita via http/ajax utilizando de json como modelo de dados. A comunicação entre o backend e o Google Cloud Storage é feita via http/dto. O Google App Engine serve é PaaS que hospeda e orquestra toda a infraestrutura de processos do TEAMMATES.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;componente.jpg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Backend se expande e divide-se em quatro componentes: UI Server, Common, Logic e Storage. O UI Server consiste em ser o componente que realiza o processamento das requisições, que podem chegar via GAE, retornará uma página da web como resposta utilizando AJAX. O componente Common é o responsavel por disponibilizar os utilitários comuns usados nos outros componentes. O Logic é o componente responsável pela lógica do negócio do TEAMMATES, gerencia os relacionamentos entre entidades, transações, higieniza os valores vindo da UI, oferece controle de acesso e é responsável pela conexão com o GAE e o serviço de email. O Storage é o componente que executa o CRUD dos dados, e é responsável or validar os dados, esconder a complexidade de armazenamento, ocultar a persistência dos objetos, mas ele não executa nenhuma criação ou exclusão em cascata.&lt;/p&gt;
&lt;p&gt;Single Page, UI Server e Logic representam um padrão Model-View-Controller.&lt;/p&gt;
&lt;p&gt;O UI Server retorna uma WebPage ao usuario atraves de WebPageServelet. O Logic utiliza os seguintes serviços para respostas de requisições: JavamailService, SendgridService, Service, além do GAE Task Queue API. O Common possui três classes internas: util, exceptions e datatransfer. O Storage possui sua API padrão em CRUD HTTP, além da classe entity que representa entidades persistentes, e a classe search usada para lidar com pesquisa e indexação.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;p&gt;Em breve.&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;estado.jpg&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;O caminho de uma requisição vinda do GAE até ser armazenada no Google Cloud Storage.&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Não foi enviado PR ao projeto.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o Youtube-dl</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/youtube-dl/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/youtube-dl/</guid>
       <description>&lt;p&gt;&amp;ndash;&lt;/p&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Thaynnara Raiany Uchôa Gonçalves.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115210050&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:thaynnara.goncalves@ccc.ufcg.edu.br&#34;&gt;thaynnara.goncalves@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ytdl-org/youtube-dl&#34;&gt;https://github.com/ytdl-org/youtube-dl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-downloads-de-vídeos&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de downloads de vídeos&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, e tem como objetivo descrever parte da arquitetura do projeto &lt;a href=&#34;https://github.com/ytdl-org/youtube-dl&#34;&gt;Youtube-dl&lt;/a&gt;, usando como base, principalmente, o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-youtube-dl&#34;&gt;Descrição Geral sobre o Youtube-dl&lt;/h2&gt;
&lt;p&gt;O youtube-dl é um projeto open-source que permite ao usuário, via comandos do terminal, fazer o download de vídeos, a partir da url do mesmo, de alguma plataforma na internet. Sendo, dentre essas, com foco no Youtube.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema é instalado na máquina do usuário, logo, este é executado por linha de comando, no terminal. Sendo assim, o usuário chama a aplicação, passando a url do vídeo a ser baixado. Logo mais, a aplicação busca o vídeo na internet, a partir da url, e o salva do disco do usuário.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagram-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;h4 id=&#34;youtube-dl-api&#34;&gt;Youtube-dl API&lt;/h4&gt;
&lt;p&gt;O sistema é instalado na máquina do usuário, no diretório $(dirname)/bin/youtube-dl, logo o mesmo é executado na própria máquina do usuário. Neste contexto, a aplicação é executado por linha de comando,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ youtube-dl &amp;lt;options&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Onde o comando &amp;lsquo;youtube-dl&amp;rsquo; está configurado para executar, com o python instalado na maquina do usuário, a aplicação salva em /bin/youtube-dl.&lt;/p&gt;
&lt;p&gt;Sendo assim, o usuário chama a aplicação com o comando youtube-dl, passando a url do vídeo a ser baixado e opções para o dowload, se desejar ou se o site onde o video está hospedado, requerir. Logo mais, a aplicação busca o vídeo via batch files e batch url, usando o protocolo adequado a cada requisição, e por fim o salva no disco do usuário, no diretório onde foi feita a chamada a aplicação.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container-diagram.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo está o diagrama de componentes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components-diagram.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;options&#34;&gt;Options&lt;/h4&gt;
&lt;p&gt;O options é o módulo responsável por fazer a validação da entrada dada pelo usuário, mas especificamente quanto a veracidade da url e o mapeamento dos parâmetros opcionais.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tecnologias
&lt;ul&gt;
&lt;li&gt;Este módulo faz uso do otparse para o recebimento das entradas.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;extractor&#34;&gt;Extractor&lt;/h4&gt;
&lt;p&gt;Este módulo é composto por varios InfoExtractors, cada um responsável por extrair a informação necessária da url por domínio específico. Ou seja, existe um InfoExtractor para cada domíminio suportado pela aplicação, por exemplo o Youtube, que tem seu pŕoprio InfoExtractor.&lt;/p&gt;
&lt;p&gt;Nesse contexto, o Extractor, dada uma url, pega o primerio InfoExtractor capaz de lidar com a mesma e extrai as informações necessárias e faz o mapeamento com as opções passadas, na chamada da aplicação, se for o caso.&lt;/p&gt;
&lt;h4 id=&#34;youtube-dl&#34;&gt;Youtube-dl&lt;/h4&gt;
&lt;p&gt;Aqui é feito o gerenciamente do fluxo da informação. Neste módulo a informação é recebida, depois dada ao Extractor, que retorna todas as informações requeridas e no formato ideal. Logo mais, a informação extraida é dada ao Downloader.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tecnologias
&lt;ul&gt;
&lt;li&gt;Aqui é feito o uso de Cache paras as urls&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;downloader&#34;&gt;Downloader&lt;/h4&gt;
&lt;p&gt;Este módulo é responsavel por fazer o download do vídeo e o salva-lo do disco do usuário. Sendo assim, aqui existem vários Files Downloader, os quais cada um tem como função baixar os dados do vídeo de acordo com diferentes protocolos. Logo, em Downloader é encontrado o File Downloader para aquele vídeo a partir do protocolo que deve ser usado para baixar o mesmo.&lt;/p&gt;
&lt;p&gt;Por exemplo, ao se deparar com um url do Youtube, é escolhido o File Downloader HTTP, pois os downloads de videos pelo Youtube funciona a partir do protocolo http.&lt;/p&gt;
&lt;p&gt;Por fim, os dados, que chegam em formato JSON, ao final do Download, sofrem um pós processamento, por parte do PostProcessor, para então ser salvo no computador do usuário.&lt;/p&gt;
&lt;h4 id=&#34;postprocessor&#34;&gt;PostProcessor&lt;/h4&gt;
&lt;p&gt;Responsável por processar os dados, em formato de JSON, baixados do vídeo, os reconstruindo novamente para o formato original&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;A url é primeiramente passada pelo usuário, que primeiramente é validada, em seguida é destinada a um InfoExtractor responsável por aquele domínio, o qual ira extrair as informações adequadas da url, estas então são dadas a um File Downloader, adequada para as mesmas, que irá usa-la para fazer o download do vídeo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;infromation_view.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento arquitetural do TypeORM</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/typeorm/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/typeorm/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Lucas Henrique de Lima e Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115110163&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:lucas.silva@ccc.ufcg.edu.br&#34;&gt;lucas.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/typeorm/typeorm&#34;&gt;https://github.com/typeorm/typeorm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----typeorm&#34;&gt;Descrição Arquitetural &amp;ndash; TypeORM&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto TypeORM. Essa descrição foi baseada principalmente no modelo C4.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do TypeORM, uma biblioteca para projetos em Javascript e Typescript. O foco aqui é a descrição do funcionamento básico da biblioteca através do padrão Active Record, como ela se comunica com os vários tipos de banco de dados e como o programador pode utilizá-la.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-typeorm&#34;&gt;Descrição Geral sobre o TypeORM&lt;/h2&gt;
&lt;p&gt;TypeORM é uma ferramenta de mapeamento objeto relacional disponível como biblioteca para projetos em Javascript e Typescript. Ela oferece uma interface de programação para gerenciar a persistência em bancos de dados. Esse tipo de ferramenta diminui ou elimina a necessidade de utilizar diretamente comandos SQL, pois é criada uma abstração na própria linguagem para o qual foi construído.&lt;/p&gt;
&lt;p&gt;Através deste documento quero descrever a arquitetura da ferramenta e como ela se integra com os bancos de dados e à linguagem Javascript e o superset Typescript. Visto que a ferramenta oferece dois padrões de ORM (Data Mapper e Active Record), estarei utilizando o Active Record como foco. A diferença entre eles pode ser entendida através &lt;a href=&#34;https://medium.com/@matheusflauzino/entenda-orm-active-record-e-data-mapper-9be60da0e799&#34;&gt;deste pequeno post&lt;/a&gt;. Na prática, em TypeORM, o Active Record usa o Data Mapper, expondo os métodos disponíveis (insert, update, delete, count, etc.) diretamente na classe que herda de &lt;code&gt;BaseEntity&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-funcionamento-do-typeorm&#34;&gt;O funcionamento do TypeORM&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Expor uma interface para a manipulação de tabelas em bancos de dados de forma mais fácil e intuitiva, utilizando-se do poder da linguagem javascript e facilitando a construção de sistemas.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O objetivo do TypeORM é sempre suportar as últimas funcionalidades de Javascript e prover funcionalidades adicionais para auxiliar no desenvolvimento de qualquer aplicação que usa banco de dados, desde pequenas aplicações com poucas tabelas até aplicações em larga escala com muitos bancos de dados. Além disso, possibilitar a escrita de código de alta qualidade, acoplamento reduzido, com graus elevados de escalabilidade e manutenabilidade de forma mais produtiva também são objetivos da ferramenta.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;É fato que a maior parte das aplicações desenvolvidas atualmente se comunicam com bancos de dados. Por muito tempo utilizou-se e até hoje utiliza-se programação direta ou linguagens de consulta de banco de dados para realizar ações simples em um banco de dados, como criar tabelas, inserir, atualizar, deletar valores e executar scripts. No entanto, muitas vezes a camada criada em um software para que ele se comunique com o banco de dados pode ser pouco intuitiva e de difícil manutenção, de acordo com a proficiência da equipe de desenvolvimento as linguagens que manipulam os bancos de dados. Em outros casos, a equipe de desenvolvimento procura organização e boa qualidade de código, sem misturar queries e scripts de banco de dados com o código da aplicação.&lt;/p&gt;
&lt;p&gt;Para mitigar problemas como estes, surgiram as ferramentas chamadas ORM - Mapeamento objeto-relacional (Object-relational mapping em inglês). Hibernate, Doctrine and Entity Framework são exemplos amplamente utilizados. Com ORMs, o programador não precisa se preocupar com os comandos em linguagens de banco de dados, pois basta usar uma interface de programação simples que faz todo o trabalho de persistência.&lt;/p&gt;
&lt;p&gt;Javascript e Typescript são altamente poderosos no ramo de desenvolvimento de aplicações, e tomando proveito disso, o TypeORM surgiu. Além de tornar a manipulação e manutenção de banco de dados mais fácil e intuitiva, TypeORM ainda oferece diversas funcionalidades que exploram a fundo o poder dessas linguagens.&lt;/p&gt;
&lt;p&gt;O TypeORM funciona em diversos ambientes e se conecta com diversos tipos de banco de dados. Uma aplicação que utiliza o TypeORM pode ser escrita em NodeJS, Browser, Cordova, PhoneGap, Ionic, React Native, NativeScript, Expo e Electron, e pode acessar bancos de dados MySQL, MariaDB, PostgreSQL, CockroachDB, SQLite, Microsoft SQL Server, sql.js e Oracle. Também há suporte experimental para MongoDB.&lt;/p&gt;
&lt;p&gt;A arquitetura usada na biblioteca é simples e bem estruturada. O diagrama abaixo mostra como a biblioteca funciona integrada aos bancos de dados e às aplicações que fazem uso deles.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-contexto.png&#34; style=&#34;width:50%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 1 - Diagrama de contexto do TypeORM
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Por se tratar de uma biblioteca, o TypeORM é integrado à aplicação que o utiliza, seja no cliente e/ou no servidor. Além disso, ele oferece uma interface de linha de comando, para que o programador possa executar ações de nível de desenvolvimento, como criação de migrações à medida que a aplicação evolui. O banco de dados a ser acessado pode estar totalmente desacoplado da máquina na qual a aplicação roda, pois isso já é previsto pelos protocolos de conexão dos bancos de dados.&lt;/p&gt;
&lt;p&gt;A figura abaixo ilustra um exemplo de implantação de um sistema que utiliza TypeORM.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-containers-implantacao.png&#34; style=&#34;width:80%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 2 - Exemplo de implantação de um sistema utilizando TypeORM
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para se comunicar com o banco de dados, o TypeORM utiliza vários componentes que são interligados e se completam. No momento em que o programador escreve código para consulta ou atualização de valores, o código é transformado em queries de acordo com o tipo de banco de dados que está sendo usado, isso porque cada banco de dados tem sua própria linguagem.&lt;/p&gt;
&lt;p&gt;Para manipular dados, é possível utilizar repositórios (utilizando o padrão Data Mapper) ou Active Records.&lt;/p&gt;
&lt;p&gt;Considere o seguinte trecho de código e uma entidade de nome Foo:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let myFoo = Foo.find({ where: { name: &#39;Bar&#39; }})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A figura abaixo mostra como a aplicação se conectará ao banco de dados e como a linha de código acima será transformada em uma consulta no banco de dados PostgreSQL.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-componentes.png&#34; style=&#34;width: 80%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 3 - Diagrama de componentes do TypeORM 
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Através da CLI do TypeORM, é possível gerar migrações. Migrações são necessárias quando a aplicação já está em produção, mas o modelo de dados é modificado ou precisa de alterações não triviais.&lt;/p&gt;
&lt;p&gt;A CLI é capaz de analisar a versão atual do modelo de dados e compará-la com uma versão anterior em busca de mudanças. Caso sejam encontradas mudanças, um script de migração é criado e fica disponível para o TypeORM para ser aplicado manualmente pelo programador ou automaticamente na próxima vez que a aplicação for iniciada.&lt;/p&gt;
&lt;p&gt;A figura abaixo ilustra o diagrama de estados de uma migração.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-informacao.png&#34; style=&#34;width: 80%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 4 - Máquina de estados de uma migração em TypeORM
    &lt;/span&gt;
&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Documento referente à arquitetura do Frontend e Deploy do projeto Eureca</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca__front_deploy/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca__front_deploy/</guid>
       <description>&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Hércules Rodrigues Anselmo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210908&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:hercules.anselmo@ccc.ufcg.edu.br&#34;&gt;hercules.anselmo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-frontend&#34;&gt;Eureca Frontend&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-deploy&#34;&gt;Eureca Deploy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-eureca&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço Eureca&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/computacao-ufcg&#34;&gt;Eureca&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar, não será descrita toda a arquitetura do Eureca. O foco aqui é a descrição do serviço Frontend e Deploy.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-eureca-frontend-e-eureca-deploy&#34;&gt;Descrição Geral sobre o Eureca-Frontend e Eureca-Deploy&lt;/h2&gt;
&lt;p&gt;O Eureca-Frontend é um projeto que tem como objetivo separar a parte visual do projeto Eureca. Atualmente está sendo possível visualizar apenas um dos sub-módulos do Eureca, que é o sub-módulo Estatísticas.&lt;/p&gt;
&lt;p&gt;O Eureca-Deploy é um projeto com principal objetivo efetuar o Deploy do Eureca, além de fazer todo o processo de configuração, escalabilidade e scripts para o Banco de Dados.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-eureca&#34;&gt;O Serviço Eureca&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Servir uma plataforma administradora para coordenadores de cursos da UFCG. A princípio está sendo desenvolvida para o curso de Ciências da Computação - UFCG. Esta plataforma tem como principal objetivo aumentar a eficiêcia e a facilidade para o coordenador com respeito aos discentes do curso. Ela contará com diversos serviços que auxiliará o coordenador na sua administração, sendo estes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monitoramento&lt;/li&gt;
&lt;li&gt;Estatísticas&lt;/li&gt;
&lt;li&gt;Comunicação&lt;/li&gt;
&lt;li&gt;Serviços&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos implantar os dados obtidos através do eureca-coleta-dados em um banco de dados para que este possa ser acessado por um outro projeto Eureca (eureca-backend), que servirá uma API para ser consumida pelo eureca-frontend, sendo este, responsável por mostrar visualmente todos os serviços disponíveis na plataforma.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema Eureca-frontend busca as informações na API através de métodos HTTP, a API logo faz consultas ao Banco de Dados e retorna uma viewer para o Coordenador.
No sistema Eureca-deploy, após receber os dados da coleta de dados, faz o procedimento de popular o Banco de Dados, mas também faz o deploy da aplicação através de containers Dockers, ele busca estas imagens no Docker Hub para levantar os respectivos containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;É importante frizar que no momento da escrita deste artigo as relações das entidades são as que estão na imagem, podendo assim, serem alteradas.&lt;/p&gt;
&lt;p&gt;No sistema Eureca-Frontend temos o Single Page Aplication, container responsável por prover uma interface para o usuário, a partir deste é possível acessar o container de Módulos, sendo este responsável por oferecer os serviços de gráficos, geração de arquivos csv e outras informação sobre os discentes, após a comunicação com o container FetcherAPI: Responsável por se comunicar com a API através da biblioteca Axios nos EndPoints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;estatisticas/ativos&lt;/li&gt;
&lt;li&gt;estatisticas/ativos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/ativos/csv&lt;/li&gt;
&lt;li&gt;estatisticas/ativos/csv?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/egressos&lt;/li&gt;
&lt;li&gt;estatisticas/egressos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/egressos/csv&lt;/li&gt;
&lt;li&gt;estatisticas/egressos/csv?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos/csv&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos/csv?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;No sistema Eureca-Deploy temos o container &amp;ldquo;Refinador&amp;rdquo;, responsável por tratar os dados recebidos do Eureca - Coleta de dados. Esses novos dados são repassados para o &amp;ldquo;Construtor do Banco de Dados&amp;rdquo; que irá implantar estes no Banco de Dados.
O Container Scripts Deploy é responsável por fazer o deploy dos containers do  Eureca-frontend, Eureca-backend e Banco de Dados, após acessar as imagens do Docker Hub.&lt;/p&gt;
&lt;h4 id=&#34;implantação&#34;&gt;Implantação&lt;/h4&gt;
&lt;p&gt;Detalhes de implantação do Eureca-Frontend:&lt;/p&gt;
&lt;p&gt;Atualmente está implantado em uma máquina virtual no LSD UFCG através de um container docker na porta 3000. É possível acessá-lo pelo link: &lt;a href=&#34;http://150.165.15.71:3000&#34;&gt;http://150.165.15.71:3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;O sistema Eureca-Deploy não tem implantação, pois como se trata de scrips para efetuar o deploy de terceiros, ele é executado apenas uma única vez. Após sua execução, o Banco de Dados postgreSQL fica hospedado, também, na mesma máquina do Eureca-Frontend, mas na porta 5432.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-implantacao.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Sobre os componentes do container Módulos:&lt;/p&gt;
&lt;p&gt;O componente Home é responsável por renderizar a Home Page, que a partir deste é possível navegar entre os outros componentes oferecidos pelo Sistema. O componente Estatística, em específico, utiliza o componente gráficos para fazer a renderização dos dados em Gráficos específicos.&lt;/p&gt;
&lt;p&gt;Sobre os componentes do container Contrutor do Banco de Dados:&lt;/p&gt;
&lt;p&gt;O componente PopulateDB é responsável por utilizar os dados refinados e passá-los para os componentes Migrations e Seeders, responssáveis por popular o banco de dados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama a seguir mostra o estado da informação da tela ativos quando o coordenador tentar acessá-la.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;estados.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Como faço parte do projeto Eureca, constantemente estou efetuando PR&amp;rsquo;s para contribuir com o projeto.&lt;/p&gt;
&lt;p&gt;-&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-deploy/pull/23&#34;&gt;Contribuição no projeto Eureca-Deploy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-frontend/pull/47&#34;&gt;Contribuição mais recente no Eureca-Frontend&lt;/a&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Erxes - Documento arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/erxes/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/erxes/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este artefato foi elaborado por Felipe de Amorim Ferreira.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118111800&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:felipe.amorim.ferreira@ccc.ufcg.edu.br&#34;&gt;felipe.amorim.ferreira@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/erxes/erxes-api&#34;&gt;https://github.com/erxes/erxes-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----erxes-api&#34;&gt;Descrição Arquitetural &amp;ndash; Erxes api&lt;/h1&gt;
&lt;p&gt;Esta descrição arquitetural é sobre a principal funcionalidade do projeto &lt;strong&gt;Erxes&lt;/strong&gt;, repositório disponível clicando &lt;strong&gt;&lt;a href=&#34;https://github.com/erxes/erxes-api&#34;&gt;aqui&lt;/a&gt;&lt;/strong&gt; e foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para deixar claro, neste documento não serão abordados todos os aspectos arquiteturais do projeto. Será destacado a descrição de um serviço específico de integração com plataformas de terceiros, que é a funcionalidade principal do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-erxes&#34;&gt;Descrição geral sobre o Erxes&lt;/h2&gt;
&lt;p&gt;O Erxes é um projeto open source e uma plataforma de crescimento em marketing. Criada para atrair clientes mais engajados, ela consegue fazer integrações de forma ilimitada com várias plataformas de atendimento ao cliente dentre elas estão plataformas de mídia, serviços de messeger, email e SMS por várias marcas.&lt;/p&gt;
&lt;h2 id=&#34;serviço-de-integração-erxes&#34;&gt;Serviço de integração Erxes&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que consegue integrar qualquer plataforma de interação entre cliente e empresa, tendo como objetivo uma relação mais próxima com o cliente e promover campanhas de marketing de forma mais impactante.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos obter o máximo de informações sobre os leads que interagem com o sistema e buscar interligar o máximo de canais de comunicação disponibilizados por eles. Com todas essas informações armazenadas conseguimos fazer testes A/B, assim, possibilitando a criação de materiais para campanhas de marketing, que são personalizadas para cada tipo de cliente. Além disso, criar triggers que são acionados quando os clientes interagem com os scripts gerados, dessa forma, permitindo com que a empresa utilizadora do &lt;strong&gt;Erxes&lt;/strong&gt; entre em contato pelos vários meios de comunicação disponibilizados.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto do Erxes API abrange os seguintes sistemas e utilizadores:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes customer&lt;/strong&gt;: Esse é o cliente que está utilizando os serviços do Erxes, ele é responsável por registrar sua marca, interagir com os clientes das marcas através das diversas plataformas e gerar os scripts de triggers para serem configurados nos sites das marcas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Company customer&lt;/strong&gt;: Esse é o cliente de uma marca registrada no Erxes, é ele que interage com a página de vendas ou serviços das marcas, consequentemente ativando vários triggers que coletam seus dados e agendam eventos(Como o envio de um email) para o sistema do Erxes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes Frontend&lt;/strong&gt;: Esse é o sistema onde o usuário interage com o Erxes, ou seja, a user interface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes API&lt;/strong&gt;: É aqui que vai ficar a maior parte da lógica de negócios, o Erxes API vai manipular as integrações de ferramentas para marketing, vai conseguir fazer um &amp;ldquo;merge&amp;rdquo; dos dados dos usuarios com várias contas, gerar scripts, disponibilizar dados para o Erxes customer e unificar a comunicação entre a marca e o Company customer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes customer&amp;rsquo;s website&lt;/strong&gt;: Essa é a página de vendas ou de serviços da marca, aqui vão ser configurados os scripts que quando acionados geram dados do usuario ou agendam eventos que são mandados para o Erxes API.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Means of communication API&lt;/strong&gt;: Essas são as APIs que irão fornecer e receber as mensagens de chat, email ou SMS e que serão unificadas para os Erxes customers interagirem com os Company customers das marcas em um único local.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Os containers do Erxes API são divididos em três serviços e dois banco de dados, apesar de estarem no mesmo repositório eles são independentes:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: Aqui é onde todas as requisições da comunicação entre client e Erxes API passam, dentro desse container estão implementadas algumas features que garantem a confiabilidade do sistema, mesmo estando instável ou caindo. Dentre várias features temos: Manipulação de arquivos XLSX para envio e recebimento, serviços cron job, implementação de um histórico de ações do sistema e filas de solução de requisições.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Email Verifier&lt;/strong&gt;: Este container tem a função de validação de grande parte dos dados fornecidos pelos Company customers, o email verifier vai verificar se os dados são válidos com ajuda de serviços externos e internos, além disso, persistirá esses dados caso forem válidos. Toda essa validação evita dados falsos e/ou duplicados, dessa forma, o banco de dados não é tão requisitado, tanto em memória quanto nas queries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Engage Email Sender&lt;/strong&gt;: O Engage Email Sender já mostra sua função pelo nome, ele é reponsável pelo envio dos emails e também lida com o agendamento do envio.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para ilustrar o documento de componentes foi expandido o container da API do tópico passado.
Também foram escolhidos os componentes mais relevantes do container, então somente alguns containers foram ilustrados.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;General API&lt;/strong&gt;: Componente responsável por manipular e encaminhar as requisições para os componentes responsáveis por resolvê-las.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;File Handler&lt;/strong&gt;: Tem como papel receber arquivos tanto por stream como diretamente, também é responsável por analisar os arquivos, se estão no formato correto ou se precisam de um &amp;ldquo;parse&amp;rdquo;, caso precise de um parse, ele realiza o parse e persiste os dados no elasticsearch.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Commands&lt;/strong&gt;: Responsável por manipular funções internas do sistema, tal como carregar dados do sistema e reiniciar serviços que não foram corretamente iniciados.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User Auth&lt;/strong&gt;: Responsável por validar as ações do usuário dentro do sistema, ele verifica se os dados de autenticação fornecidos usuário permitem ele realizar determinada ação dentro do sistema.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message Broker&lt;/strong&gt;: Componente responsável pela tradução de mensagens entre protocolos formais de mensagens. Isto permite que serviços interdependentes &amp;ldquo;falem&amp;rdquo; uns com os outros diretamente, mesmo que tenham sido escritos em línguas diferentes ou implementados em plataformas diferentes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cron jobs&lt;/strong&gt;: Responsável por executar uma tarefa recorrente repetidamente em algum tempo mais tarde. A ação de dar um comando para agendar uma tarefa para um tempo específico e de forma repetida é responsabilidade deste componente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;As trocas de mensagens, em companhia dos dados gerados pela interação dos clientes das marcas, exercem um papel primordial para o funcionamento da aplicação. Com eles nós conseguimos gerar relatórios dos comportamentos dos usuários e promover várias campanhas de marketing mais acertivas. Abaixo ilustro os estados de uma email enviado pelo sistema.&lt;/p&gt;
&lt;p&gt;Descrição da sequência de estados:&lt;/p&gt;
&lt;p&gt;Primeiro o email começa a ser produzido pelo usuário, em seguida ele pode ser enviado ou salvo. Caso o email seja enviado, ele pode ser aberto, ir para span, ser cancelado, ou devolvido. Ao cancelar o envio ele é automaticamente salvo, e ao ser salvo ele pode ser deletado. Quando o email é devolvido ele pode ser reenviado ou editado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;states.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>OpenFaaS Of-Watchdog</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/ofwatchdog/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/ofwatchdog/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por David Ferreira Quaresma.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210041&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:david.quaresma@ccc.ufcg.edu.br&#34;&gt;david.quaresma@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/openfaas/of-watchdog&#34;&gt;https://github.com/openfaas/of-watchdog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----proxy-reverso-do-openfaas-of-watchdog&#34;&gt;Descrição Arquitetural &amp;ndash; Proxy Reverso do OpenFaaS (Of-Watchdog)&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/openfaas&#34;&gt;OpenFaaS&lt;/a&gt;, mais precisamente o componente chamado &lt;a href=&#34;https://github.com/openfaas/of-watchdog&#34;&gt;Of-Watchdog&lt;/a&gt; - uma versão alternativa do watchdog clássico do OpenFaaS. Essa descrição foi feita com baseada no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Vale salientar que neste documento não será descrito toda a arquitetura do OpenFaaS, como já mecionado. Aqui iremos descrever o proxy reverso utilizado pela plataforma, componente este de função essencial para a comunicação com as funções conteinerizadas e extração de métricas.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-opefaas&#34;&gt;Descrição Geral sobre o OpeFaaS&lt;/h2&gt;
&lt;p&gt;O OpenFaaS é um framework de provisionamento de funções como serviço que possibilita a rápida implementação e deploy de aplicações sob o paradigma de computação em Funções como Serviço, também se responsabilizando pela escalabilidade da aplicação (pré configurada pelo usuário). Para mais detalhes sobre esta plataforma, visite &lt;a href=&#34;https://www.openfaas.com/&#34;&gt;este link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;of-watchdog---proxy-reverso-do-openfaas&#34;&gt;Of-Watchdog - Proxy reverso do OpenFaaS&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um servidor HTTP que atua como um proxy reverso para a execução de funções e microserviços, podendo ser usado de forma independente ou como um ponto de entrada para conteineres com o OpenFaaS.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Possibilitar uma versão do watchdog que dê suporte para proxy HTTP e STDIO, o que habilita o reuso de memória (em contraste ao clássico que precisa iniciar um novo conteiner para cada invocação de função) e um atendimento de requisições mais eficiente (devido a não necessidade de iniciar novas instâncias para a atender requisições).&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;No OpenFaaS, cada função é encapsulada em um contêiner, e dentro dele há o handler da função e o proxy reverso. Neste contexto, o Of-Watchdog (um proxy reverso, como já mencionado) executa dentro do contêiner e junto à função. Além do próprio handler da função, o Of-Watchdog também comunica-se com o FaaS Provider (responsável por encaminhar requisições às réplicas de funções)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Uma vez que o OpenFaaS trata-se de uma plataforma de funções como serviço, é natural que seus componentes esteja decomposto à nível de contêineres. Nesta seção iremos apresentar os componentes mais próximos do of-watchdog, que são eles o próprio contêiner em que o of-watchdog executa e o contêiner em que executa o outro processo que se comunica com o of-watchdog, o Faas Provider.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;A principal informação que trafega através do Of-Watchdog são as requisições enviadas às funções em que o Of-Watchdog está proxeando. Neste caso, a requisição advinda do FaaS Provider (que a recebeu do OpenFaaS Gateway) é interceptada pelo Of-Watchdog e encaminhada para o Handler da função.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-informacao.png&#34; alt=&#34;fig7&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o projeto Farol Covid</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/farolcovid/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/farolcovid/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Natan Macena Ribeiro.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 114111371&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:natan.ribeiro@ccc.ufcg.edu.br&#34;&gt;natan.ribeiro@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ImpulsoGov/farolcovid&#34;&gt;https://github.com/ImpulsoGov/farolcovid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----farolcovid&#34;&gt;Descrição Arquitetural &amp;ndash; FarolCovid&lt;/h1&gt;
&lt;p&gt;A fonte utilizada para produção deste documento foi o projeto &lt;a href=&#34;https://github.com/ImpulsoGov/farolcovid&#34;&gt;Farol Covid&lt;/a&gt;. A partir desse projeto (&lt;a href=&#34;https://github.com/ImpulsoGov/farolcovid&#34;&gt;Farol Covid&lt;/a&gt;), este documento propõe uma descrição arquitetural baseada essencialmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;, pelo qual permite que diferentes stakeholders possam compreender o funcionamento da ferramenta a partir de algumas visões arquiteturais.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-farol-covid&#34;&gt;Descrição Geral sobre o Farol Covid&lt;/h2&gt;
&lt;p&gt;O Farol Covid é uma ferramenta de monitoramento do risco de colapso no sistema de saúde em municípios brasileiros com a COVID-19. Além de apresentar a situação atual da COVID-19 nos estados ou municípios, esse projeto permite que governantes consigam definir políticas de contingenciamento da doença, baseando-se em indicadores bem definidos que inclusive, permitem a realização de simulações que projetam possíveis cenários para a região de interesse. Para mais detalhes sobre o projeto abordado, acesse &lt;a href=&#34;https://farolcovid.coronacidades.org/&#34;&gt;este link&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O objetivo do projeto é disponibilizar um serviço para coleta e visualização de dados relacionados a COVID-19, apresentando análises e indicadores da situação da doença para uma determinada região.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A idéia é viabilizar que gestores públicos (estaduais e municipais), possuam uma ferramenta que mostra a situação atual da COVID-19 e indica possíveis cenários baseados no comportamento da doença na região de seu mandato.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;A partir da introdução, podemos expecificar o sistema do FarolCovid, como um serviço Web que apresenta informações contidas nos sistemas de base de dados brasileiros &lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.IO&lt;/a&gt; e &lt;a href=&#34;https://datasus.saude.gov.br/&#34;&gt;DataSUS&lt;/a&gt;, considerando os interesses especificos do usuário. De maneira geral, o sistema funciona como um facilitador, entre o usuário e as bases de dados anteriormente citadas, em que simplifica a obtenção de determinada informação por meio de refinamento e operações de analises sobre tais bases de dados.&lt;/p&gt;
&lt;p&gt;Assim, podemos representar a aplicação como uma entidade intermediária (&amp;ldquo;FarolCovid&amp;rdquo;) entre as entidades &amp;ldquo;Usuário&amp;rdquo; e &amp;ldquo;Brasil.IO&amp;rdquo; juntamente com &amp;ldquo;DataSUS&amp;rdquo;, como é ilustrado no diagrama de contexto abaixo:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;01_diagrama_de_contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Como containers do FarolCovid, podemos elencar 3 entidades: Web Page, View e API.&lt;/p&gt;
&lt;p&gt;O primeiro deles, &lt;strong&gt;Web Page&lt;/strong&gt;, é responsável por pela representação gráfica do sistema, ou seja, todo o HTML que o browser irá interpretar e renderizar para o usuário final.&lt;/p&gt;
&lt;p&gt;O elemento &lt;strong&gt;View&lt;/strong&gt;, trata-se de toda lógica do negócio, realizando todas as operações com os dados (refinamento, filtragem e análise) coletados das bases de dados (&lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.IO&lt;/a&gt; e &lt;a href=&#34;https://datasus.saude.gov.br/&#34;&gt;DataSUS&lt;/a&gt;) atravéz de uma &lt;a href=&#34;http://datasource.coronacidades.org/br/&#34;&gt;API&lt;/a&gt; desenvolvida para isso. Esse contêiner utilizar Python como linguagem e é acompanhado pelos frameworks Flask e Streamlit. O sistema é executado numa nuvem Heroku, utilizando uma máquina virtual com o sistema operacional Ubuntu 18.04 LTS.&lt;/p&gt;
&lt;p&gt;O container &lt;strong&gt;API&lt;/strong&gt;, é um conjunto de rotinas e padrões de programação para acesso das bases de dados do FarolCovid. Foi construido para o sistema que estamos apresentando e o projeto (que pode ser acessado &lt;a href=&#34;https://github.com/ImpulsoGov/coronacidades-datasource&#34;&gt;neste link&lt;/a&gt;) possui o nome de &lt;em&gt;Coronacidades API&lt;/em&gt;. Assim como o FarolCovid, o &lt;a href=&#34;https://github.com/ImpulsoGov/coronacidades-datasource&#34;&gt;Coronacidades API&lt;/a&gt; é servido por uma maquina virtual Heroku e foi desenvolvido em Python juntamente com o framework Django, a partir do padrão de projeto MTV (Model, Template, View).&lt;/p&gt;
&lt;p&gt;Veja principais endpoints utilizados pelo FarolCovid:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;br/cities/cases/full: Fornece histórico completo de dados do &lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.IO&lt;/a&gt; com a taxa e estimativa dos casos ativos&lt;/li&gt;
&lt;li&gt;br/cities/simulacovid/main: Dados filtrados para servir a aplicação SimulaCovid do FarolCovid&lt;/li&gt;
&lt;li&gt;br/cities/farolcovid/main: Dados filtrados e indicadores de cidades&lt;/li&gt;
&lt;li&gt;br/states/farolcovid/main: Dados filtrados e indicadores de estados&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*Para os demais endpoints acesse &lt;a href=&#34;http://datasource.coronacidades.org/br/&#34;&gt;API.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Abaixo encontra-se o diagrama de container para o que foi discutido anteriormente:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;02_diagrama_de_containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;A fim de detalhamento, podemos dividir o container View em cinco componentes: Resources, Model, Helper Server, Utils e Pages.&lt;/p&gt;
&lt;p&gt;O componente Resources é composto por um conglomerado de scripts em Python que são utilizados em páginas HTML, compondo de forma fragmentada, funcionalidades para interação do usuário no sistema.&lt;/p&gt;
&lt;p&gt;Model provê o conceito matemático utilizado para a realização de simulações e projeções epidemiológicas, através da linguagem em Python.&lt;/p&gt;
&lt;p&gt;Helper Server utiliza o microframework Flask juntamente com Python, para fornecer um serviço de cache do sistema, carregando dados via API calls.&lt;/p&gt;
&lt;p&gt;O elemento Utils, é responsável pela realização de diferentes funções relacionadas ao gerenciamento da seção do usuário no sistema coletando, informações da seção dos usuário e interações através do Streamlit framework, integrado com Python.&lt;/p&gt;
&lt;p&gt;Por último temos o componente Pages que usa Python, HTML e o framework Streamlit, para fornecer visualização interativa com dados. É nesse componente, encontra-se todas as subaplicações disponibilizadas pelo FarolCovid (descritas na seção &lt;strong&gt;Visão de Informação&lt;/strong&gt; deste documento) e se comunica com a API para buscas, filtragens e realização de análises dos dados.&lt;/p&gt;
&lt;p&gt;Logo abaixo, temos o diagrama de componentes para o FarolCovid:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;03_diagrama_de_componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como sabemos, a principal funcionalidade do projeto Farol Covid é apresentar informações pré-processadas, no formato de análises, de acordo com uma determinada localidade. Dessa forma, nesta seção abordaremos de maneira simplificada, o percurso habitual que os usuários percorrem na busca das informações disponibilizadas pela aplicação em estudo.&lt;/p&gt;
&lt;p&gt;Na página inicial, o usuário se depara com uma breve apresentação da plataforma e, logo em seguida, uma caixa de seleção é disponibilizada dividida em três tipos: Estado, Região de Saúde (algo particular de cada estado) e Município (Municípios do estado selecionado). Podemos perceber que há uma hierarquia entre os tipos disponíveis, onde um &amp;ldquo;Município&amp;rdquo; é um subtipo de uma &amp;ldquo;Região de Saúde&amp;rdquo; e de um &amp;ldquo;Estado&amp;rdquo;, assim como &amp;ldquo;Região de Saúde&amp;rdquo; é subtipo de um &amp;ldquo;Estado&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Logo abaixo, temos as informações apresentadas de acordo com o que foi selecionado pelo usuário. Essas informações são mostradas a partir de métricas bem definidas (que  estão disponíveis para consulta no botão &amp;ldquo;Entenda a Classificação dos Níveis&amp;rdquo;) e indicam, por exemplo, situação e controle da doença, capacidade do sistema de saúde, etc.&lt;/p&gt;
&lt;p&gt;Além disso, é disponibilizado quatro subaplicações que permitem uma análise mais detalhada de acordo com a localidade anteriormente escolhida, sendo elas: Simula Covid, que permite a realização de uma simulação da situação da Covid considerando variáveis pertinentes; Distanciamento Social, que mostra a taxa de isolamento social; Saúde em Ordem, que dá uma prognóstico no que diz respeito a possíveis atividades econômicas seguras para reabertura; Onda Covid, que mostra a evolução da curva de contágio da Covid-19 em relação a outros países.&lt;/p&gt;
&lt;p&gt;Para cada interação do usuário, a página é automaticamente recarregada de acordo com o que foi selecionado. Por default, o elemento pré-selecionado do sistema é o estado do Acre.&lt;/p&gt;
&lt;p&gt;Vejamos abaixo, uma máquina de estados que ilustra fluxo da informação da aplicação estudada, para principais interações de um usuário:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;04_fluxo_informacao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento arquitetural do Querido Diário</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/querido-diario/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/querido-diario/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Matheus Alves dos Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110503&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:matheus.santos@ccc.ufcg.edu.br&#34;&gt;matheus.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/okfn-brasil/querido-diario&#34;&gt;https://github.com/okfn-brasil/querido-diario&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----querido-diário&#34;&gt;Descrição Arquitetural &amp;ndash; Querido Diário&lt;/h1&gt;
&lt;div align=&#34;center&#34; style=&#34;margin-top:1.5rem;&#34;&gt;
    &lt;img src=&#34;logo.png&#34; style=&#34;width:20rem;&#34;&gt;
&lt;/div&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/okfn-brasil/querido-diario&#34;&gt;Querido Diário&lt;/a&gt; da &lt;em&gt;&lt;a href=&#34;https://github.com/okfn-brasil&#34;&gt;Open Knowledge Brasil&lt;/a&gt;&lt;/em&gt;, baseando-se especialmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante ressaltar que o Querido Diário é composto por módulos cujas implementações estão em repositórios à parte do principal. Por isso, este documento incluirá módulos como a &lt;a href=&#34;https://github.com/okfn-brasil/querido-diario-api&#34;&gt;API do Querido Diário&lt;/a&gt; e o serviço de &lt;a href=&#34;https://github.com/okfn-brasil/busca-querido-diario&#34;&gt;Busca por Palavras-Chave&lt;/a&gt;. Em contrapartida, o conteúdo de repositórios relacionados que não têm impacto direto no sistema, como o site de divulgação do projeto, não será incluído.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-e-objetivos&#34;&gt;Descrição Geral e Objetivos&lt;/h2&gt;
&lt;p&gt;Os Diários Oficiais estão entre as melhores fontes de informação sobre as ações da administração pública brasileira, especialmente por sua granularidade, existindo até mesmo no âmbito municipal. Contudo, mesmo com a &lt;a href=&#34;https://www.gov.br/acessoainformacao/pt-br&#34;&gt;Lei de Acesso à Informação&lt;/a&gt; vigente, a maioria destas publicações não está disponível em formatos adequados. Elas são encontradas quase exclusivamente em formato PDF.&lt;/p&gt;
&lt;p&gt;Nesse cenário, o Querido Diário visa rastrear as fontes destas publicações nos 5.570 municípios brasileiros, extrair as informações ali contidas e, posteriormente, disponibilizá-las na forma de dados abertos.&lt;/p&gt;
&lt;p&gt;Ao criar uma fonte confiável e centralizada para estas informações, o Querido Diário busca auxiliar a sociedade civil no acompanhamento dos atos públicos municipais, bem como fomentar avanços nas ferramentas de fiscalização da administração pública brasileira.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Os usuários do Querido Diário formam um grupo muito heterogêneo, contemplando desde servidores públicos e jornalistas até organizações não governamentais de controle social. De forma geral, todos os cidadãos que busquem acesso aos atos públicos dos municípios brasileiros são potenciais usuários deste &lt;em&gt;software&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Ainda assim, é possível dividi-los em dois grupos principais: a &lt;strong&gt;sociedade civil&lt;/strong&gt; e as &lt;strong&gt;ferramentas de fiscalização da administração pública&lt;/strong&gt;. Ambos utilizam o Querido Diário como fonte centralizada e confiável de informação acerca dos Diários Oficiais municipais. Contudo, diferenciam-se à medida que as ferramentas de fiscalização não usam os dados disponibilizados apenas como fonte de informação. Elas vão além, aplicando-os na identificação de padrões, detecção de problemas e promoção de impactos positivos na administração pública das cidades brasileiras.&lt;/p&gt;
&lt;p&gt;Para atender às demandas desses dois grupos de usuários, o Querido Diário precisa acessar uma grande quantidade de &lt;strong&gt;portais dos poderes públicos municipais&lt;/strong&gt; nos quais os Diários Oficiais são disponibilizados. A partir dos documentos encontrados, as informações de interesse são extraídas e estruturadas adequadamente para que possam ser, posteriormente, disponibilizadas.&lt;/p&gt;
&lt;p&gt;O diagrama apresentado na Figura 1 descreve sucintamente o contexto em que o Querido Diário está inserido.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-contexto.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 1 - Diagrama de contexto do Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;containers&#34;&gt;&lt;em&gt;Containers&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;O Querido Diário é composto atualmente pelos quatro &lt;em&gt;containers&lt;/em&gt; que serão descritos a seguir.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Raspador de Diários Oficiais&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; responsável por acessar os portais do poder público onde são disponibilizados os Diários Oficiais municipais, bem como por extrair as informações de interesse sobre estes documentos. Ele foi implementado em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;, mais especificamente através das bibliotecas &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt; e &lt;a href=&#34;https://scrapy.org/&#34;&gt;Scrapy&lt;/a&gt;. Este &lt;em&gt;container&lt;/em&gt; se comunica com os portais do poder público através de requisições HTTP e aplica rotinas de pré-processamento nos dados (por meio de &lt;em&gt;middleware&lt;/em&gt;) antes de enviá-los para o armazenamento usando &lt;em&gt;Data Mappers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Pré-Processador de Dados&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; responsável por aplicar transformações aos dados brutos extraídos dos Diários Oficiais, colocando-os em um formato estruturado, acessível e mais amigável à compreensão humana. Ele foi implementado em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt; e disponibiliza diversas rotinas de tratamento e limpeza de dados, sendo utilizado como um &lt;em&gt;middleware&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Banco de Dados&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; responsável por armazenar, de forma estruturada, todas as informações extraídas a partir dos Diários Oficiais municipais. Ele foi implementado em &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; e outros &lt;em&gt;containers&lt;/em&gt; utilizam &lt;em&gt;Data Mappers&lt;/em&gt; para acessá-lo.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;API do Querido Diário&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; que viabiliza o acesso externo e eficiente aos dados armazenados no banco de dados. Ela foi implementada em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;, mais especificamente através das bibliotecas &lt;a href=&#34;https://elasticsearch-py.readthedocs.io/en/master/&#34;&gt;Elastic Search&lt;/a&gt;, &lt;a href=&#34;https://fastapi.tiangolo.com/&#34;&gt;Fast-API&lt;/a&gt; e &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;. Foram utilizados padrões REST e o acesso a esta API se dá por meio de requisições HTTP em formato JSON. Os dois &lt;em&gt;endpoints&lt;/em&gt; disponíveis atualmente estão descritos a seguir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GET /gazzettes/&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Retorna informações sobre os Diários Oficiais que atendam às características descritas no &lt;em&gt;payload&lt;/em&gt; da requisição.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Atributos do &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;since&lt;/code&gt;:&lt;/strong&gt; Data mínima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;until&lt;/code&gt;:&lt;/strong&gt; Data máxima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;keywords&lt;/code&gt;:&lt;/strong&gt; Lista das palavras-chave que os Diários Oficiais retornados devem conter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page&lt;/code&gt;:&lt;/strong&gt; Número da página de resultados a ser retornada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page_size&lt;/code&gt;:&lt;/strong&gt; Tamanho da página de resultados a ser retornada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{ 
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;since&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-09-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-10-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;keywords&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;queimadas&amp;#34;&lt;/span&gt;],
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page_size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GET /gazzettes/&amp;lt;territory_id&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Retorna informações sobre os Diários Oficiais que atendam às características descritas no &lt;em&gt;payload&lt;/em&gt; da requisição e que sejam do município cujo código no IBGE é igual ao &lt;strong&gt;territory_id&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Atributos do &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;since&lt;/code&gt;:&lt;/strong&gt; Data mínima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;until&lt;/code&gt;:&lt;/strong&gt; Data máxima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;keywords&lt;/code&gt;:&lt;/strong&gt; Lista das palavras-chave que os Diários Oficiais retornados devem conter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page&lt;/code&gt;:&lt;/strong&gt; Número da página de resultados a ser retornada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page_size&lt;/code&gt;:&lt;/strong&gt; Tamanho da página de resultados a ser retornada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{ 
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;since&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-03-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-08-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;keywords&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;medidas&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;covid-19&amp;#34;&lt;/span&gt;],
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page_size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama apresentado na Figura 2 descreve os &lt;em&gt;containers&lt;/em&gt; que compõem o Querido Diário.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-containers.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 2 - Diagrama de &lt;i&gt;containers&lt;/i&gt; do Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Além destes &lt;em&gt;containers&lt;/em&gt;, futuramente serão implementados outros dois: um para o &lt;em&gt;&lt;strong&gt;Front-End&lt;/strong&gt;&lt;/em&gt;, que permitirá o acesso facilitado aos resultados e informações do Querido Diário, e um para &lt;strong&gt;Processamento de Linguagem Natural&lt;/strong&gt;, que permitirá a execução de algoritmos de Inteligência Artificial com os dados extraídos.&lt;/p&gt;
&lt;h3 id=&#34;implantação&#34;&gt;Implantação&lt;/h3&gt;
&lt;p&gt;Até a conclusão deste documento, o processo de implantação do Querido Diário não havia sido concluído e, portanto, nem todas as decisões sobre este tópico estavam disponíveis.&lt;/p&gt;
&lt;p&gt;Contudo, já se sabe que o serviço &lt;a href=&#34;https://www.digitalocean.com/products/spaces/&#34;&gt;Spaces Object Storage&lt;/a&gt; da &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt; será utilizado para a hospedagem de todos os arquivos e que a integração contínua com o código hospedado no &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; será feita por meio do &lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Observando a arquitetura do Querido Diário em mais detalhes, os &lt;em&gt;containers&lt;/em&gt; descritos anteriormente podem ser subdivididos em componentes.&lt;/p&gt;
&lt;p&gt;No Raspador de Diários Oficiais, o componente mais importante talvez seja o &lt;strong&gt;Extrator de Documentos&lt;/strong&gt;. Ele é formado por um extenso conjunto de &lt;em&gt;spiders&lt;/em&gt; do &lt;a href=&#34;https://scrapy.org/&#34;&gt;Scrapy&lt;/a&gt; que, através de requisições HTTP, recuperam os arquivos dos Diários Oficiais municipais no formato em que estão disponibilizados. Já o componente &lt;strong&gt;Raspador de Dados&lt;/strong&gt; é aquele responsável por identificar e executar a forma mais adequada de raspagem das informações contidas nestes arquivos.&lt;/p&gt;
&lt;p&gt;É durante essa raspagem de dados que ocorre o uso (como &lt;em&gt;middleware&lt;/em&gt;) do Pré-Processador de Dados ou, mais especificamente, do conjunto de &lt;strong&gt;Rotinas de Tratamento de Dados&lt;/strong&gt; implementadas em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt; que o compõe. Esses componentes são responsáveis por garantir que, uma vez extraídos, os dados assumam a forma acessível e amigável que se espera deles. A partir deste ponto, o componente &lt;strong&gt;Modelador de Dados&lt;/strong&gt; irá garantir que os dados sejam armazenados, estruturando-os adequadamente e enviando-os ao Banco de Dados por meio de &lt;em&gt;Data Mappers&lt;/em&gt; do &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Já na API do Querido Diário, é possível identificar dois componentes principais. O primeiro deles, a &lt;strong&gt;Interface de Acesso&lt;/strong&gt;, utiliza o &lt;a href=&#34;https://fastapi.tiangolo.com/&#34;&gt;Fast-API&lt;/a&gt; para manipular as requisições HTTP recebidas e extrair os parâmetros de consulta que serão encaminhandos ao Buscador de Dados. Além disso, também é este componente que envia os resultados das consultas aos usuários que realizaram as requisições à API do Querido Diário.&lt;/p&gt;
&lt;p&gt;Por fim, o &lt;strong&gt;Buscador de Dados&lt;/strong&gt; é o componente responsável por recuperar o conjunto de dados que atenda às especificações dos parâmetros de consulta recebidos. Para isso, o acesso ao Banco de Dados utiliza o &lt;a href=&#34;https://elasticsearch-py.readthedocs.io/en/master/&#34;&gt;Elastic Search&lt;/a&gt; e os &lt;em&gt;Data Mappers&lt;/em&gt; do &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;, permitindo que mesmo consultas complexas (como a busca por palavras-chave nos documentos) sejam executadas de forma eficiente.&lt;/p&gt;
&lt;p&gt;O diagrama apresentado na Figura 3 descreve os componentes do Querido Diário que foram citados ao longo desta seção.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-componentes.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 3 - Diagrama de componentes do Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;visão-da-informação&#34;&gt;Visão da Informação&lt;/h2&gt;
&lt;p&gt;Apesar da grande quantidade de dados que é manipulada pelo Querido Diário, todas as informações podem ser centralizadas no conceito de Diário Oficial.&lt;/p&gt;
&lt;p&gt;Inicialmente, o Diário Oficial é um documento &lt;strong&gt;disponibilizado&lt;/strong&gt; em algum portal de poder público municipal, geralmente em formatos pouco amigáveis ao processamento por máquina (como PDFs). Por isso, a primeira atividade do Querido Diário é acessá-lo e obtê-lo. Uma vez que o documento foi &lt;strong&gt;recuperado&lt;/strong&gt;, as informações de interesse contidas nele precisam ser &amp;ldquo;raspadas&amp;rdquo;, de modo que o sistema passe a lidar apenas com esse conjunto de dados &lt;strong&gt;extraído&lt;/strong&gt;. Durante este processo, o conjunto de dados ainda deve sofrer diversas transformações para que se torne mais acessível e compreensível, ou seja, se torne &lt;strong&gt;tratado&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Com essas etapas concluídas, o Diário Oficial pode finalmente ser &lt;strong&gt;armazenado&lt;/strong&gt; no banco de dados do Querido Diário, onde permanecerá indefinidamente. Finalmente, todas as publicações de Diários Oficiais que forem armazenadas pelo Querido Diário poderão ser &lt;strong&gt;requisitadas&lt;/strong&gt; por qualquer indivíduo que tenha interesse em conhecer mais sobre os atos do poder público nos municípios brasileiros.&lt;/p&gt;
&lt;p&gt;O fluxo de informações descrito nesta seção está apresentado no diagrama de estados da Figura 4.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;visao-informacao.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 4 - Visão da Informação dos Diários Oficiais no Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
</description>
     </item>
   
     <item>
       <title>Projeto Eureca - Da coleta de dados ao backend</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca-da_coleta_de_dados_ao_backend/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca-da_coleta_de_dados_ao_backend/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Paulo Mendes da Silva Júnior.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210922&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:paulo.junior@ccc.ufcg.edu.br&#34;&gt;paulo.junior@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projetos documentados: &lt;/br&gt;
&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-coleta-de-dados&#34;&gt;https://github.com/computacao-ufcg/eureca-coleta-de-dados&lt;/a&gt; &lt;/br&gt;
&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-backend&#34;&gt;https://github.com/computacao-ufcg/eureca-backend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----projeto-eureca-coleta-de-dados-ao-backend&#34;&gt;Descrição Arquitetural &amp;ndash; Projeto Eureca (Coleta de dados ao backend)&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura de uma parte do projeto &lt;strong&gt;Eureca&lt;/strong&gt; (&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-coleta-de-dados&#34;&gt;Coleta de dados&lt;/a&gt; e &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-backend&#34;&gt;Backend&lt;/a&gt;). Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-eureca-da-coleta-de-dados-ao-backend&#34;&gt;Descrição geral sobre o Eureca (da coleta de dados ao backend)&lt;/h2&gt;
&lt;p&gt;O projeto &lt;strong&gt;Eureca&lt;/strong&gt; se trata de um projeto da coordenação do curso de Computação@UFCG, projeto ao qual eu estou vinculado, que tem a finalidade de auxiliar a coordenação do curso em suas ações a curto e longo prazo. Com funcionalidades de monitoramento, estatísticas, comunicação e serviços que englobam todos os alunos do curso de Computação na UFCG.&lt;/p&gt;
&lt;h2 id=&#34;eureca-da-coleta-de-dados-ao-backend&#34;&gt;Eureca (da coleta de dados ao backend)&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Prover uma interface de monitoramento para a coordenação do curso, que possua informações sobre como os alunos estão se comportando de acordo com o período aos quais se encontram, em relação as suas notas, presenças e demais especificidades. Essas informações são divididas em quatro grandes blocos: Monitoramento, Estatísticas, Comunicação e Serviços.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos que o coordenador seja capaz, de por exemplo, fazer um acompanhamento mais direto com aqueles alunos que se encontram em situações críticas. Além de observar também os que se encontram &amp;ldquo;Acima da média&amp;rdquo; e também os regulares. O sistema também irá possuir serviços de estatísticas sobre todos os alunos que já passaram pelo curso, sejam eles graduados, ativos ou evadidos.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O repositório Eureca-coleta-de-dados inicia se comunicando com o sistema de controle acadêmico a fim de baixar páginas .html de alunos do curso de Computação@UFCG, onde ocorre todo um processamento nessas páginas, desde a raspagem dos dados relevantes das páginas .html até a criação dos relacionamentos dos dados em arquivos .csv para inserção no banco de dados. Logo após, esses dados são inseridos no Banco de Dados Eureca-Deploy, a partir disso, o Eureca-Backend, que consiste de uma API REST, acessa o banco de dados atráves de requisições HTTP e expõe endpoints para que a API seja acessada pelo Eureca-Frontend.&lt;/p&gt;
&lt;p&gt;Logo abaixo temos o diagrama de contexto referente a parte de coleta de dados e backend do projeto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama_contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O crawler acessa o sistema de controle acadêmico (serviço externo) e baixa várias páginas .html por aluno, que são as de cadastro, histórico, faltas, notas, etc. Essas páginas são processadas por parsers, que filtram os dados relevantes que estão nas páginas, esses dados então são formatados e por fim, retornados na saída padrão. Logo após scripts shell fazem a separação dos dados adicionado os relacionamentos e separando os dados em arquivos .csv que correspondem aos dados que serão inseridos em cada tabela do banco de dados, incluindo relacionamentos de chaves estrangeiras, chave auto incremental, etc. Assim os dados estarão prontos para serem inseridos no banco de dados.
Com o banco de dados populado, o eureca-backend (API REST) o acessa através de queries SQL e o banco de dados retorna respostas JSON para o backend.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama_container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;implantação&#34;&gt;Implantação&lt;/h4&gt;
&lt;p&gt;Todo o sistema (exceto o Eureca-coleta-de-dados) está hospedado em uma máquina virtual Linux (Ubuntu) do LSD (Laboratório de Sistemas Distribuídos) da UFCG, onde nessa máquina virtual encontram-se 3 (três) contêineres Docker em execução, o primeiro é Eureca-deploy rodando na porta 5432, o segundo é o Eureca-Backend rodando na porta 5500, e por fim, o Eureca-frontend rodando na porta 3333.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Obs:&lt;/strong&gt; O Eureca-coleta-de-dados não encontra-se em execução porque o coordenador, no momento, está fazendo esse processo de download das páginas e geração dos dados para o banco de dados localmente. Além de que esse é um processo que não é feito com frequência.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-implantacao.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;endpoints&#34;&gt;Endpoints&lt;/h5&gt;
&lt;p&gt;A API REST que se trata do repositório Eureca-Backend, no momento em que este documento foi escrito possui os seguintes endpoints.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/api/estatisticas/ativos&lt;/li&gt;
&lt;li&gt;/api/estatisticas/ativos?de=periodo&lt;/li&gt;
&lt;li&gt;/api/estatisticas/ativos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;/api/estatisticas/ativos/csv&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos?de=periodo&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos/csv&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos?de=periodo&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos/csv&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No diagrama de componentes (localizado abaixo) temos os componentes principais de cada container, além de seus relacionamentos e responsabilidades. Em nosso projeto o &lt;strong&gt;Crawler&lt;/strong&gt; obtém as páginas .html de alunos no sistema de controle acadêmico, então os &lt;strong&gt;Parsers&lt;/strong&gt; (que são scripts python) utilizam essas páginas para fazer uma espécie de raspagem dos dados relevantes (web scrapping) utilizando o Beautiful Soap, que é um pacote python para análise de documentos, e assim, retirar as informações relevantes para o projeto.&lt;/p&gt;
&lt;p&gt;Então os &lt;strong&gt;Scripts Shell&lt;/strong&gt; fazem uso desses dados filtrados para gerar arquivos .csv contendo relacionamentos desses dados para formar os dados que irão compor as tabelas do banco de dados. Após isso os dados são inseridos no banco de dados, e esses dados são acessados a partir de uma API REST (Eureca-Backend) que possui &lt;strong&gt;Controllers&lt;/strong&gt; que fornecem as rotas e se comunicam com os &lt;strong&gt;Models&lt;/strong&gt;, onde estes fazem as requisições que utilizam queries SQL, que são feitas através de uma lib chamada psycopg, que nada mais que é que um adaptador de banco de dados Postgres, onde o mesmo acessa um banco de dados Postgres através de queries SQL. Então esses dados resultantes das queries são processados no backend e retornados no formato JSOn em endpoints ou rotas, que são acessadas pelo Eureca-Frontend que renderiza esses dados de forma amigável em uma interface do usuário.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;As informações trafegam pelo sistema de modo que tudo se inicia com os dados brutos, que são as páginas .html do SCA, então essas páginas são processadas pelos scripts de parser que filtram os dados relevantes para a aplicação. Logo, esses dados filtrados são processados por scripts shell que geram arquivos .csv que criam relacionamentos entre os dados, de modo que esses arquivos são os dados que serão inseridos nas tabelas no banco de dados.&lt;/p&gt;
&lt;p&gt;Logo a seguir, podemos ver o diagrama de máquina de estados referente à coleta de dados:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;maquina_estados.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;contribuições-concretas&#34;&gt;Contribuições concretas&lt;/h3&gt;
&lt;p&gt;Como eu faço parte do projeto Eureca, então eu já fiz inúmeras Pull Request&amp;rsquo;s, principalmente nos repositórios Eureca-Deploy e Eureca-Backend, algumas dessas PR&amp;rsquo;s podem ser vistas nos seguintes links: &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-deploy/pulls?q=is%3Apr+is%3Aclosed&#34;&gt;Eureca-Deploy-pull_requests&lt;/a&gt; e &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-backend/pulls?q=is%3Apr+is%3Aclosed&#34;&gt;Eureca-Backend-pull_requests&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento Arquitetural do Axios</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/axios/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/axios/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Marcus Vinícius de Farias Barbosa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110906&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:marcus.barbosa@ccc.ufcg.edu.br&#34;&gt;marcus.barbosa@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;https://github.com/axios/axios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----axios&#34;&gt;Descrição Arquitetural &amp;ndash; Axios&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;Axios&lt;/a&gt;.
As descrições e diagramas aqui presentes foram produzidos usando como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;O Axios é um cliente HTTP, que pode ser utilizado tanto no navegador quando em projetos Node.js. Ele é disponibilizado como um pacote npm, e fornece uma API para o envio de requisições que lida com &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&#34;&gt;XMLHttpRequest&lt;/a&gt; do navegador e com o &lt;a href=&#34;https://nodejs.org/api/http.html&#34;&gt;http&lt;/a&gt; do Node.js, desse modo o mesmo código pode ser utilizado no lado cliente e no lado servidor.&lt;/p&gt;
&lt;p&gt;De acordo com sua documentação oficial, o Axios conta com as seguintes funcionalidades:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Faz requisições com XMLHttpRequest a partir do browser;&lt;/li&gt;
&lt;li&gt;Faz requisições http a partir do node.js;&lt;/li&gt;
&lt;li&gt;Tem suporte à API &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Intercepta requisições e respostas;&lt;/li&gt;
&lt;li&gt;Transforma dados de requisições e respostas;&lt;/li&gt;
&lt;li&gt;Cancela requisições;&lt;/li&gt;
&lt;li&gt;Faz transformações automáticas para dados JSON;&lt;/li&gt;
&lt;li&gt;Fornecer proteção no lado cliente contra &lt;a href=&#34;https://pt.wikipedia.org/wiki/Cross-site_request_forgery&#34;&gt;XSRF&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Além disso, por ser uma biblioteca bastante conhecida e utilizada no meio do desenvolvimento web, existem diversas bibliotecas criadas pela comunidade que interagem com o Axios e adicionam a ele novos recursos, que vão desde interceptores de requisições a cache.&lt;/p&gt;
&lt;p&gt;Mais informações podem ser encontradas &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h2&gt;
&lt;p&gt;Oferecer uma biblioteca baseada em Promises para envio de requisições HTTP de forma simples e sem que o usuário se preocupe se a requisição será feita a partir do navegador ou de um servidor Node.js.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Como o Axios se trata de uma biblioteca, os usuários finais são os desenvolvedores de &lt;em&gt;software&lt;/em&gt;, que a importam em seus projetos e assim fazem uso de suas funcionalidades.&lt;/p&gt;
&lt;p&gt;Em relação à comunicação com sistemas externos, a principal interação realizada é com o servidor alvo das requisições definido pelo usuário. Esse servidor precisa dispor de uma API HTTP, pois esse é o protocolo de comunicação utilizado pelo Axios em suas requisições.&lt;/p&gt;
&lt;p&gt;A comunicação também é feita com &lt;em&gt;plugins&lt;/em&gt; de terceiros, que são bibliotecas desenvolvidas para interagirem com os recursos do Axios e adicionam a ele novas funcionalidades como suporte a &lt;em&gt;cookies&lt;/em&gt;, manipulação de &lt;em&gt;cache&lt;/em&gt; e comunicação com &lt;em&gt;middlewares&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O diagrama de contexto abaixo ilustra quais entidades interagem com o Axios.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context-diagram.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;&lt;em&gt;Containers&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Como o Axios não é um sistema de &lt;em&gt;software&lt;/em&gt;, ou seja, não é composto por aplicações nem possui armazenamento de dados, mas uma biblioteca, ele é constituído de um único &lt;em&gt;container&lt;/em&gt; que possui todos os módulos de código necessários para seu funcionamento e implementação de suas funcionalidades.&lt;/p&gt;
&lt;p&gt;A sua API disponibiliza os seguintes recursos:&lt;/p&gt;
&lt;h4 id=&#34;envio-de-requisições&#34;&gt;Envio de requisições&lt;/h4&gt;
&lt;h5 id=&#34;axiosconfig&#34;&gt;axios(config)&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de uma requisição POST para um serviço local
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;post&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/user/12345&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Fred&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Flintstone&amp;#39;&lt;/span&gt;
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de uma requisição GET para um serviço remoto
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://bit.ly/2mTM3nY&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;responseType&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;stream&amp;#39;&lt;/span&gt;
})
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;pipe&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createWriteStream&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ada_lovelace.jpg&amp;#39;&lt;/span&gt;))
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;axiosurl-config&#34;&gt;axios(url[, config])&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de envio de uma requisição GET, utilizando o método me envio padrão
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/user/12345&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;criação-de-instância-axios&#34;&gt;Criação de instância Axios&lt;/h4&gt;
&lt;h5 id=&#34;axioscreateconfig&#34;&gt;axios.create([config])&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de criação de uma instância Axios
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;baseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://some-domain.com/api/&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;timeout&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;headers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-Custom-Header&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foobar&amp;#39;&lt;/span&gt;}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mais detalhes sobre a API podem ser encontrados &lt;a href=&#34;https://github.com/axios/axios#axios-api&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;implantação&#34;&gt;Implantação&lt;/h3&gt;
&lt;p&gt;A sua implantação também é simples se comparado com sistemas de &lt;em&gt;software&lt;/em&gt;, pois, tendo sido instalado no projeto através de algum gerenciador de pacotes (como npm e yarn) ou pelo CDN, é preciso apenas se atentar para os requisitos de ambiente: o navegador e sua versão, e a versão no Node.js. Como essas informações são voláteis e dependem da versão atual do Axios, é recomendado verificá-las na &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;documentação&lt;/a&gt; oficial.&lt;/p&gt;
&lt;p&gt;O diagrama de implantação abaixo ilustra como é feita a implantação do Axios. Nele é possível notar que a biblioteca pode ser utilizada tanto em aplicações que são executadas por um navegador quanto em aplicações Node.js em um servidor. Além disso, nota-se também que os &lt;em&gt;plugins&lt;/em&gt; utilizados estão no mesmo nível que o Axios e são importados e utilizados de modo semelhante a ele.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deployment-diagram.png&#34; alt=&#34;Diagrama de Implantação&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;O Axios é composto pelos seguintes componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Axios&lt;/strong&gt;: fornece uma instância Axios com todos os métodos necessários configurados.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Core&lt;/strong&gt;&lt;/em&gt;: contém a lógica de domínio do Axios. É nesse componente em que são implementados o gerenciador de interceptadores, a manipulação de configurações e envio de requisições.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Defaults&lt;/strong&gt;&lt;/em&gt;: define as configurações iniciais para a criação de uma instância Axios, como os &lt;em&gt;aliases&lt;/em&gt; para os métodos de requisição e a definição do &lt;em&gt;adapter&lt;/em&gt; adequado.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Adapters&lt;/strong&gt;&lt;/em&gt;: responsável pelo envio de requisições e resolução de &lt;em&gt;Promises&lt;/em&gt; retornadas assim que uma resposta é recebida. Existe um adapter para lidar com http do Node.js e outro para lidar com o XHR do navegador.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Helpers&lt;/strong&gt;&lt;/em&gt;: dispõe de implementações genéricas que não são específicas para a lógica de domínio, mas que são utilizadas por toda a aplicação, como gerenciamento de &lt;em&gt;cookies&lt;/em&gt;, &lt;em&gt;parsers&lt;/em&gt; de cabeçalhos HTTP e &lt;em&gt;polyfills&lt;/em&gt; do navegador.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama de componentes abaixo ilustra os componentes apresentados e sua comunicação.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components-diagram.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;Dentre os vários tipos de dados que o Axios manipula, o que foi escolhido para ser apresentado nessa seção foi o dado que representa uma requisição, desde a chamada ao método de envio ao seu dispacho para o destinatário.&lt;/p&gt;
&lt;p&gt;Através do seguinte fluxo de processamento de uma requisição é possível notar os estados que ela assume ao logo do processo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O método para envio de uma requisição é chamado, e inicia-se o processo de configuração da requisição;&lt;/li&gt;
&lt;li&gt;O Axios verifica a existência de cabeçalhos e os manipula, adicionando cabeçalhos necessários;&lt;/li&gt;
&lt;li&gt;Os dados (cabeçalhos e informações enviadas no corpo) da requisição são transformados para um formato padrão;&lt;/li&gt;
&lt;li&gt;É validado se esses dados são do tipo &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;ArrayBuffer&lt;/em&gt;, &lt;em&gt;Buffer&lt;/em&gt; ou &lt;em&gt;Stream&lt;/em&gt;:
&lt;ul&gt;
&lt;li&gt;Se sim, a requisição continua sendo processada;&lt;/li&gt;
&lt;li&gt;Se não, seu processo de envio é cancelado;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;São definidos dados de autenticação básica HTTP na requisição;&lt;/li&gt;
&lt;li&gt;O endereço (URL) do destinatário da requisição é formatado, bem como o protocolo utilizado;&lt;/li&gt;
&lt;li&gt;Se foi definido algum &lt;em&gt;proxy&lt;/em&gt;, a requisição recebe toda a configuração referente a ele, como porta, caminho e nome;&lt;/li&gt;
&lt;li&gt;A requisição é então enviada.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama abaixo ilustra o que foi explanado acima, dando enfoque nos estados assumidos por uma requisição.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;fsm-diagram.png&#34; alt=&#34;Diagrama de Máquina de Estados&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h2&gt;
&lt;p&gt;Ainda não foram abertas PRs para o repositório oficial do Axios porque ainda é necessário validar a documentação já
produzida e produzir uma versão em inglês.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>UFCGPro</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/matheusaraujo/</link>
       <pubDate>Sun, 11 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/matheusaraujo/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Matheus Silva Araújo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210375&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:matheus.araujo@ccc.ufcg.edu.br&#34;&gt;matheus.araujo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/lucis/ufcg-pro&#34;&gt;https://github.com/lucis/ufcg-pro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----extensão-do-controle-acadêmico-da-universidade-federal-de-campina-grande&#34;&gt;Descrição Arquitetural &amp;ndash; Extensão do Controle Acadêmico da Universidade Federal de Campina Grande.&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/lucis/ufcg-pro&#34;&gt;UFCGPro&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-parlametria&#34;&gt;Descrição Geral sobre o Parlametria&lt;/h2&gt;
&lt;p&gt;O UFCGPro é uma ferramenta para melhorar o uso do Controle Acadêmico da Universidade Federal de Campina Grande.&lt;/p&gt;
&lt;h2 id=&#34;extensão-do-controle-acadêmico&#34;&gt;Extensão do Controle Acadêmico&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para auxiliar discentes e docentes em atividades comuns da rotina acadêmica institucional como disciplinas, matrículas e afins.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Adicionar recursos ao controle acadêmico da Universidade Federal de Campina Grande a fim de tornar mais práticas as atividades listadas nesse documento.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto do sistema se resume ao usuário, o browser e a extensão. O usuário adiciona a extensão ao browser, o usuário acessa o Controle Acadêmico pelo browser e a extensão complementa recursos do Controle Acadêmico.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaContexto.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Os containers do sistema se resumem ao browser, pois a extensão UFCGPro funciona individualmente no browser de cada usuário, sem a necessidade de estar implantada num servidor externo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaContainer.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Os componentes do sistema podem ser descritos por: &lt;em&gt;background.js&lt;/em&gt;, que faz a comunicação entre o usuário e os &lt;em&gt;injectors&lt;/em&gt;; os &lt;em&gt;injectors&lt;/em&gt;, que atuam como controllers do sistema e acionam os &lt;em&gt;components&lt;/em&gt;; que por sua vez, fazem as chamadas necessárias e a comunicação com o sistema do Controlador Acadêmico&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaComponentes.png&#34; alt=&#34;componentes&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Nesse exemplo, temos a visão da informação no momento de realizar o planejamento e automatização de uma matrícula. Primeiramente, o usuário acessa a tela de planner, preenche as disciplinas, o sistema verifica se é possível realizar a matrícula e por fim, realiza o processamento do pedido.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaInformacional.png&#34; alt=&#34;informação&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;A pull request realizada para o repositório pode ser vista através do link: &lt;a href=&#34;https://github.com/lucis/ufcg-pro/pull/26&#34;&gt;https://github.com/lucis/ufcg-pro/pull/26&lt;/a&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Bypass PayWalls</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/bypass_paywalls/</link>
       <pubDate>Sat, 10 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/bypass_paywalls/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Sammara Beserra Nunes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210039&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:sammara.nunes@ccc.ufcg.edu.br&#34;&gt;sammara.nunes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/iamadamdev/bypass-paywalls-chrome&#34;&gt;https://github.com/iamadamdev/bypass-paywalls-chrome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-análise-do-twitter&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de análise do twitter&lt;/h1&gt;
&lt;p&gt;Este post descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/iamadamdev/bypass-paywalls-chrome&#34;&gt;ByPass PayWalls&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-parlametria&#34;&gt;Descrição Geral sobre o Parlametria&lt;/h2&gt;
&lt;p&gt;O Bypass PayWalls é uma extensão para os navegadores Google Chrome e Mozilla Firefox que permite o acesso a certos sites que antes eram bloqueados por acesso pago.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-monitoramento-do-twitter&#34;&gt;O Serviço de monitoramento do twitter&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;É uma extensão de navegador que permite o acesso a páginas que são permitidas apenas a assinantes, assim como a limitação dessas mesmas leituras.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Permitir que o conteúdo seja divulgado a quem não pode pagar com uma ferramenta também gratuita.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O plug-in em questão funciona com a manipulação de cookies e arquivos javascript, oferecendo um serviço semelhante aos bloqueadores de anúncio, porém bloqueando acesso pago (ou &amp;ldquo;paywalls&amp;rdquo;), possibilitando a leitura de artigos bloquados e/ou limitados. Antes de executar alguma remoção, ele verifica se o  domínio do site está na lista pré-configurada de &amp;ldquo;domínios permitidos&amp;rdquo;. Caso contrário, permanecerá o acesso bloqueado.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;c4_diagram.png&#34; style=&#34;width:40%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Como trata-se se um plug-un, não há muitos containers. Apenas o navegadores permitidos (Mozilla Firefox e Chrome), o plug-in e a página a ser manipulada pelo plug-in.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;containers_diagram.png&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No diagrama de containers, podemos ter uma visão se seus principais serviços para que ele funcione. Como se trata de um plug-in para navegador, seus componentes estão, sua maioria, no seu código (escrito em javascript) e consiste em um arquivo sites.js que armazena todos os sites permitidos em uma const, além da comunição com os navegadores Google Chrome e Firefox. Lembrando que é sempre recomendado limpar os cookies do navegador antes de ver se é algum erro do plug-in.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;components_diagram.png&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O plug-in coleta o domínio da página e, caso seja um domínio permitido, ele manipula a visualização caso seja uma página com o acesso bloquado.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;diagrama_estados.png&#34; style=&#34;width:70%&#34;&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Ainda nenhum.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o SAPS</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/saps/</link>
       <pubDate>Sat, 10 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/saps/</guid>
       <description>&lt;hr&gt;
&lt;img src=&#34;./logo.png&#34; style=&#34;width: 50%; display: flex; margin: 0 auto;&#34;/&gt;
Projeto SAPS para construção de uma plataforma automatizada que realize o cálculo do método SEBAL utilizando imagens de satélite.
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Thiago Yuri Evaristo de Souza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117211156&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:thiago.souza@ccc.ufcg.edu.br&#34;&gt;thiago.souza@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ufcg-lsd/saps-engine&#34;&gt;https://github.com/ufcg-lsd/saps-engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/ufcg-lsd/saps-engine&#34;&gt;SAPS&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-saps&#34;&gt;Descrição Geral sobre o SAPS&lt;/h2&gt;
&lt;p&gt;O SAPS é um projeto que tem como objetivo processar imagens de satélite utilizando o &lt;a href=&#34;https://en.wikipedia.org/wiki/SEBAL&#34;&gt;método SEBAL&lt;/a&gt; de forma a facilitar o usuário (geralmente um pesquisador) que deseja realizar analises sobre os resultados obtidos pelo seu processamento automático. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S0098300419302961&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;imagem-de-satélite&#34;&gt;Imagem de satélite&lt;/h3&gt;
&lt;p&gt;Imagem de satélite é um arquivo de imagem (&lt;a href=&#34;https://en.wikipedia.org/wiki/TIFF&#34;&gt;TIFF&lt;/a&gt;) obtido por sensoriamento remoto a partir de um satélite artificial. Existem diferentes satélites de recolha de imagens, os mais conhecidos são QuickBird, Ikonos, Landsat e Spot.&lt;/p&gt;
&lt;p&gt;No contexto do SAPS, a única família de satélite com suporte é a &lt;a href=&#34;https://en.wikipedia.org/wiki/Landsat_program&#34;&gt;Landsat&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;método-sebal&#34;&gt;Método SEBAL&lt;/h3&gt;
&lt;p&gt;SEBAL (Surface Energy Balance Algorithm for Land) é um algoritmo que usa o balanço de energia de superfície para estimar aspectos do ciclo hidrológico, mapeando então informações como evapotranspiração, crescimento de biomassa, déficit hídrico e umidade do solo.&lt;/p&gt;
&lt;p&gt;Essa quantificação do balanço de energia é calculado usando dados de satélite que originam características da superfície terrestre, como albedo da superfície, índice de área foliar, índice de vegetação e temperatura da superfície. Além das imagens de satélite, o modelo SEBAL requer dados meteorológicos, como velocidade do vento, umidade, radiação solar e temperatura do ar relativos a região de analise.&lt;/p&gt;
&lt;h3 id=&#34;scripts&#34;&gt;Scripts&lt;/h3&gt;
&lt;p&gt;O SAPS é composto de 3 grandes partes para realizar seus processamentos, são eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inputdownloading: responsável pela aquisição dos dados a serem utilizados, como dados de elevação, metereológicos ou até mesmo as próprias imagens de satélite.&lt;/li&gt;
&lt;li&gt;preprocessing: responsável pela preparação dos dados obtidos como por exemplo, extração de pixels de nuvens/sombra de nuvens, &lt;a href=&#34;https://docs.qgis.org/2.14/pt_BR/docs/user_manual/working_with_projections/working_with_projections.html&#34;&gt;reprojeção de imagens&lt;/a&gt; e entre outros.&lt;/li&gt;
&lt;li&gt;processing: responsável pela aplicação do algoritmo final (por exemplo, SEBAL) nos dados preprocessados para geração de novos dados uteis para o usuário a fim de realizar analise e extração de informações.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essas fases são selecionadas pelo usuário formando um pipeline de processamento, cada uma dessas fases é implementada e executada utilizando containers Docker configurados e preparados para execução do passo necessitando somente dos dados de entrada.&lt;/p&gt;
&lt;h2 id=&#34;saps&#34;&gt;SAPS&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Implementar uma plataforma em que usuários possam requisitar/acompanhar/recuperar processamentos de imagens de satélite em um determinado intervalo de tempo e localização, que serão realizados de forma automática.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos específicos&lt;/h3&gt;
&lt;p&gt;Ter uma plataforma abrangente, que possa processar imagens de diversos tipos de familias de satélite (LANDSAT, &amp;hellip;) e computar diversos métodos de processamentos de imagens, além do SEBAL.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;contexto.svg&#34; alt=&#34;diagrama-contexto&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de contexto é apresentado como se da a interação dos demais elementos com a plataforma SAPS. Primeiramente temos os clientes, que requisitam processamentos de imagens de satélite (em um intervalo de tempo e lugar), depois os mesmos acessam para acompanhar a execução do seu processamento e por fim depois que finalizar, recuperar os dados calculados pelo SAPS a partir das imagens fornecidas na entrada.&lt;/p&gt;
&lt;p&gt;Temos também o serviço de e-mail que é utilizado pelo SAPS para envio de mensagens para o usuário, principalmente dos dados finais de um processamento. Além dos datasets (imagens de satélite, dados de elevação e dados meteorológicos) que são bastante uteis para obtenção de informações para o processamento. O serviço de storage serve para armazenar dados finais ou parciais dos processamentos feitos pelo SAPS, isto é destinado a um serviço externo que possui uma boa tecnologia que lida melhor com questões de segurança e persistência dos dados.&lt;/p&gt;
&lt;p&gt;Por último, o serviço de execução de trabalhos que é responsável por receber um workload e executa-lo, e depois enviar informações sobre a execução. Por exemplo, selecionar uma VM com 2GB ram e 4 CPUs, levantar um container docker X (no caso do SAPS será os algoritmos dos passos de inputdownloading, preprocessing ou processing) e executar os comandos Y e Z com os argumentos A e B. Por fim, o serviço vai acompanhar a execução e coletar os exitcodes de cada comando e concluir se o trabalho foi bem sucedido ou falho. O que é importante nesse serviço é sabe o estado final da execução e manter os resultados em um local acessível e seguro.&lt;/p&gt;
&lt;p&gt;Existe uma coisa complicada associada entre os datasets e o serviço de execução de trabalhos que será abordado na visão de componentes.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;containers.svg&#34; alt=&#34;diagrama-containers&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de containers, o sistema SAPS é amplicado em três novos blocos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GUI: Responsável por interagir com o usuário de forma facilitada e gerar workload&lt;/li&gt;
&lt;li&gt;API da aplicação: Responsável por interagir com os pedidos da GUI de workload ou obtenção de informação e processa-las&lt;/li&gt;
&lt;li&gt;Database: Responśavel por registrar informações sobre processamentos e usuários&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;gui&#34;&gt;GUI&lt;/h4&gt;
&lt;p&gt;A GUI possui uma interface com algumas operações simples como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Submeter nova requisição de processamento&lt;/strong&gt; gerando workload a aplicação do SAPS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Acompanhar processamento&lt;/strong&gt; verificando os estados do processamento fazendo com que a aplicação do SAPS gere uma listagem das informações para o usuário&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Obter resultados&lt;/strong&gt; gerando workload a aplicação do SAPS para organização dos dados resultantes e disponibização dos mesmos por meio de um email&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-da-aplicação&#34;&gt;API da aplicação&lt;/h4&gt;
&lt;p&gt;A API possui algumas operações simples como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adicionar nova requisição de processamento&lt;/li&gt;
&lt;li&gt;Adicionar novo usuário&lt;/li&gt;
&lt;li&gt;Recuperar informações sobre processamentos&lt;/li&gt;
&lt;li&gt;Enviar resultados de processamentos&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;database&#34;&gt;Database&lt;/h4&gt;
&lt;p&gt;O banco de dados é responsável por manter os dados do usuário e processamentos.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;componentes.svg&#34; alt=&#34;diagrama-componentes&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagram de componentes são apresentados três componentes principais pertencentes a aplicação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dispatcher: Responsável por registrar novos processamentos ou usuários, e obtenção dos mesmos, além de envio de email para o usuário obter os resultados dos processamentos&lt;/li&gt;
&lt;li&gt;Archiver: Responsável por obter processamentos finalizados e prontos para arquivamento dos dados resultantes/parciais no serviço de storage&lt;/li&gt;
&lt;li&gt;Scheduler: Responsável por agendar as execuções dos passos do processamento com o serviço de execução de trabalhos&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;por-que-existe-uma-camada-a-mais-entre-os-datasets-e-o-serviço-de-execução-de-trabalhos&#34;&gt;Por que existe uma camada a mais entre os datasets e o serviço de execução de trabalhos?&lt;/h4&gt;
&lt;p&gt;Como dito na seção sobre o modelo de contexto, o serviço de execução de trabalhos executa um workload enviado pelo SAPS (Scheduler) que irá ser processado em um ambiente. Esse ambiente por sua vez irá rodar os algoritmos dos passos de inputdownloading, preprocessing e processing que estão em containers Dockers.&lt;/p&gt;
&lt;p&gt;Na execução desses algoritmos (principalmente de fase inputdownloding), irá ser feito a obtenção dos dados presentes nos datasets de imagens de satélite, de dados de elevação e metereológicos, no caso, ainda existe uma pequena camada do SAPS no que está sendo executado representada pelos algoritmos rodados no serviço de execução de jobs para comunicação com esses datasets.&lt;/p&gt;
&lt;p&gt;Importante ressaltar que essa seção é útil para enchar a introdução vista na visão geral com a plataforma SAPS em questões de como o dado é obtido, não sendo feito por nenhum dos componentes, mas por um algoritmo que é executado dentro do serviço de execução de trabalhos.&lt;/p&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da informação&lt;/h3&gt;
&lt;img src=&#34;./fluxo-informacao.svg&#34; style=&#34;width: 50%; display: flex; margin: 0 auto;&#34;/&gt;
&lt;p&gt;No diagrama de fluxo de informação é descrito os estados que o processamento pode atingir, começando no estado &lt;strong&gt;created&lt;/strong&gt; e finalizando (se bem sucedido) em &lt;strong&gt;archived&lt;/strong&gt;. Existem alguns pontos de falha nos estados de downloading, preprocessing, processing e archiving, que são originados por:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;downloading: os arquivos relativos ao processamento não foram encontrados nos datasets de imagens de satélite, metereológicos ou dados de elevação, ou estão corrumpidos. Também pode acontecer por uma situação inesperada que ocorreu nessa fase.&lt;/li&gt;
&lt;li&gt;preprocessing/processing: os arquivos baixados não estão como esperado, ou estão ausentes, ou alguma situação inesperada&lt;/li&gt;
&lt;li&gt;archiving: os arquivos a serem armazenados apresentam problemas para enviar ao serviço de storage, ou algum problema inesperado&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições concretas&lt;/h1&gt;
&lt;p&gt;Não realizei a submissão do PR por questões de idioma, as informações/documentações feitas pelo SAPS são em Inglês. Num futuro próximo, pretendo realizar essa contribuição.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Fission Serverless Platform</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/fission/</link>
       <pubDate>Sat, 10 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/fission/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve diversos aspectos arquiteturais da plataforma de
computação &lt;em&gt;serverless&lt;/em&gt; para funções-como-serviço - &lt;em&gt;Fission&lt;/em&gt;.
A promessa dessa plataforma é permitir que desenvolvedores se concentrem
unicamente na tarefa de implementação da lógica de negócio, deixando os detalhes de
implantação sobre a responsabilidade da plataforma.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Paulo Feitosa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116211477&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:paulo.felipe.silva@ccc.ufcg.edu.br&#34;&gt;paulo.felipe.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/fission/fission&#34;&gt;https://github.com/fission/fission&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---fission-core-services&#34;&gt;Descrição Arquitetural - Fission Core Services&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto
&lt;a href=&#34;https://fission.io/&#34;&gt;Fission&lt;/a&gt;.
Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura da Fission.
O foco deste documento será a descrição arquitetural dos serviços de &lt;em&gt;core business&lt;/em&gt; da
plataforma em questão.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-fission&#34;&gt;Descrição Geral sobre o &lt;em&gt;Fission&lt;/em&gt;.&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Fission&lt;/em&gt; é uma plataforma de computação serverless para funções-como-serviço que tem
como objetivo principal retirar dos desenvolvedores toda a carga de implantação de
software. Dessa forma, os programadores podem se preocupar apenas com os detalhes da
implementação da lógica de negócio.&lt;/p&gt;
&lt;p&gt;A plataforma garante realizar automaticamente o &lt;em&gt;scale-up&lt;/em&gt; e &lt;em&gt;scale-down&lt;/em&gt; dos recursos
computacionais para executar as funções quando estiverem sobre uma alta ou baixa
utilização. Mais detalhes sobre a plataforma podem ser acessados
&lt;a href=&#34;https://docs.fission.io/docs/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;fission-core-services&#34;&gt;&lt;em&gt;Fission Core Services&lt;/em&gt;&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O &lt;em&gt;Core Services&lt;/em&gt; tem como principais objetivos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;permitir a implantação de funções dentro da plataforma &lt;em&gt;Fission&lt;/em&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;autorizar o acesso de clientes às funções implantadas;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Para alcançar os objetivos gerais, o &lt;em&gt;Core Services&lt;/em&gt; provê uma API REST que é ponto
de entrada de diversas operações da plataforma. A API permite a realização de CRUD
de funções por desenvolvedores, dessa forma, o &lt;em&gt;Core Services&lt;/em&gt; é o responsável por
interagir com os serviços internos para que a operação seja concluída.&lt;/p&gt;
&lt;p&gt;Além disso, depois de implantada a função pode ser invocada pelos seus clientes.
Neste caso, a API deve rotear as requisições HTTP para as instâncias que executam
o código-fonte da função.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os principais sistemas que interagem com o &lt;em&gt;Core Services&lt;/em&gt;,
assim como as suas responsabilidades.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;eventos-de-entrada&#34;&gt;Eventos de entrada&lt;/h4&gt;
&lt;p&gt;Podemos observar que o &lt;em&gt;Core Services&lt;/em&gt;, como já descrito anteriormente, também funciona
como o &lt;em&gt;Back-end&lt;/em&gt; da &lt;em&gt;Fission&lt;/em&gt;. Os Desenvolvedores e seus Clientes podem interagir
com a plataforma por meio do &lt;em&gt;Front-end&lt;/em&gt; ou do &lt;em&gt;Fission CLI&lt;/em&gt; (um software de linha
de comando).&lt;/p&gt;
&lt;p&gt;Quando os Desenvolvedores realizam a implantação de uma função, a plataforma
disponibiliza um &lt;em&gt;endpoint&lt;/em&gt; que pode ser acessado para invocar a execução da função.
Assim, a forma mais comum dos Clientes interagirem com a plataforma é
pelo disparo de requisições HTTP para invocar funções.&lt;/p&gt;
&lt;h4 id=&#34;eventos-de-saída&#34;&gt;Eventos de saída&lt;/h4&gt;
&lt;p&gt;Como o &lt;em&gt;Core Services&lt;/em&gt; é o ponto de entrada da plataforma, pode ser razoável imaginar
que todos os recursos sejam resolvidos por esse componente, contudo, diversas tarefas
são delegadas para outros componentes.&lt;/p&gt;
&lt;p&gt;Como apresentado no diagrama acima, o &lt;em&gt;Kubernetes&lt;/em&gt; é responsável por gerenciar os
recursos computacionais para permitir que as funções processem requisições dos seus
clientes. Dessa forma, o &lt;em&gt;Core Services&lt;/em&gt; precisa interagir com o Kubernetes para
realizar o CRUD de funções, além de consultar os endereços das réplicas da função
para roteá-las. O &lt;em&gt;Kubernetes&lt;/em&gt; também é o responsável por realizar o escalonamento
das instâncias em execução da função com base na métrica de utilização de CPU.&lt;/p&gt;
&lt;p&gt;Quando um desenvolvedor realiza o &lt;em&gt;deployment&lt;/em&gt; de uma função, o &lt;em&gt;Core Services&lt;/em&gt; se
encarrega de transformar o código-fonte em uma função implantável. Após o processo de
&lt;em&gt;build&lt;/em&gt;, o &lt;em&gt;StorageSVC&lt;/em&gt; é o responsável por armazenar os artefatos de
implantação resultantes. Dessa forma, quando necessário, o &lt;em&gt;Kubernetes&lt;/em&gt; pode recuperar
esses artefatos para criar novas réplicas da função.&lt;/p&gt;
&lt;p&gt;Além disso, o &lt;em&gt;Core Services&lt;/em&gt; também funciona como um &lt;em&gt;Proxy&lt;/em&gt; para serviços externos
que pode ser oferecidos por terceiros dentro da plataforma.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os serviços que compõem o &lt;em&gt;Fission Core Services&lt;/em&gt; assim
como as suas responsabilidades e interações com outros sistemas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture-Container.png&#34; alt=&#34;containers&#34;&gt;&lt;/p&gt;
&lt;p&gt;Como podemos observar, o &lt;em&gt;Core Services&lt;/em&gt; é composto pelos serviços: &lt;em&gt;Controller&lt;/em&gt;,
&lt;em&gt;Router&lt;/em&gt;, &lt;em&gt;Executor&lt;/em&gt;, &lt;em&gt;Function Pod&lt;/em&gt; e &lt;em&gt;Builder Manager&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;em&gt;Controller&lt;/em&gt; expõe uma API que pode ser acessada pelos usuários da plataforma
via &lt;em&gt;Fission CLI&lt;/em&gt; ou &lt;em&gt;Fission UI&lt;/em&gt;. O &lt;em&gt;Controller&lt;/em&gt; também funciona como &lt;em&gt;Gateway&lt;/em&gt;
para os serviços internos e externos da plataforma.&lt;/p&gt;
&lt;h4 id=&#34;crud-de-funções&#34;&gt;CRUD de funções&lt;/h4&gt;
&lt;p&gt;Quando o &lt;em&gt;Controller&lt;/em&gt; recebe uma requisição para realizar o &lt;em&gt;CRUD&lt;/em&gt; de funções, ela
é repassada para o &lt;em&gt;Kubernetes&lt;/em&gt; via
&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34;&gt;CRDs&lt;/a&gt;
que armazena informações sobre a função e o seu código-fonte. O &lt;em&gt;Builder Manager&lt;/em&gt;
observa os eventos de &lt;em&gt;CRUD&lt;/em&gt; e dispara o processo de transformar o código-fonte da
função em um artefato executável.&lt;/p&gt;
&lt;p&gt;Após o processo de &lt;em&gt;build&lt;/em&gt; da função, o &lt;em&gt;Builder Manager&lt;/em&gt; armazena os artefatos
resultantes no &lt;em&gt;StorageSVC&lt;/em&gt; para que, posteriormente, possa ser recuperado e usado
na criação de novas réplicas da função.&lt;/p&gt;
&lt;h4 id=&#34;invocação-de-funções&#34;&gt;Invocação de funções&lt;/h4&gt;
&lt;p&gt;Quando o &lt;em&gt;Controller&lt;/em&gt; recebe uma requisição HTTP para disparar a execução de uma
função, ele repassa a responsabilidade para o &lt;em&gt;Router&lt;/em&gt;. O &lt;em&gt;Router&lt;/em&gt; em seguida
consulta o &lt;em&gt;Executor&lt;/em&gt; para saber se existe alguma instância/réplica da função
disponível para processar a requisição recebida. Se existir, o &lt;em&gt;Router&lt;/em&gt; apenas
encaminha a requisição para a réplica. Caso contrário, o &lt;em&gt;Router&lt;/em&gt; requisita ao
&lt;em&gt;Executor&lt;/em&gt; a criação de novas instâncias da função via &lt;em&gt;Function Pod&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Function Pod&lt;/em&gt; é o serviço responsável por carregar e executar uma função, para isso
ele realiza o &lt;em&gt;download&lt;/em&gt; da função executável no &lt;em&gt;StorageSVC&lt;/em&gt;, cria um processo para
a função quee aceita requisições via um servidor HTTP. Dessa forma, o &lt;em&gt;Router&lt;/em&gt; pode
encaminhar as requisições para o servidor HTTP associado à função.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta o diagrama de componentes do serviço &lt;em&gt;Function Pod&lt;/em&gt;
que pertence ao &lt;em&gt;Fission Core Services&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture-Components.png&#34; alt=&#34;components&#34;&gt;&lt;/p&gt;
&lt;p&gt;Podemos observar que &lt;em&gt;Function Pod&lt;/em&gt; possui dois componentes principais: &lt;em&gt;Fetcher&lt;/em&gt; e
&lt;em&gt;Environment Container&lt;/em&gt;. O &lt;em&gt;Fetcher&lt;/em&gt; é o responsável por realizar o &lt;em&gt;download&lt;/em&gt;
dos artefatos de &lt;em&gt;deployment&lt;/em&gt; de uma função. Esses artefatos são compartilhados com
o &lt;em&gt;Environment Container&lt;/em&gt; via um &lt;em&gt;Shared Volume&lt;/em&gt;, ou seja, com o protocolo de
comunicação via &lt;em&gt;File System&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Dessa forma, quando o &lt;em&gt;Fetcher&lt;/em&gt; requisita a inicialização da função, o &lt;em&gt;Environment
Container&lt;/em&gt; cria um processo que carrega a função executável, que por meio de um
servidor HTTP pode processar as requisições encaminhadas pelo &lt;em&gt;Router&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da informação&lt;/h3&gt;
&lt;p&gt;A máquina de estados abaixo apresenta a visão da informação do estado das funções
dentro da plataforma &lt;em&gt;Fission&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture-Visao-da-Informacao.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
&lt;p&gt;O diagrama expõe os possíveis estados de uma função assim como as possíveis
transições dos estados. Os estados mais importantes são: &lt;strong&gt;Implantada&lt;/strong&gt; e
&lt;strong&gt;Disponível&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Quando uma função está &lt;strong&gt;Implantada&lt;/strong&gt;, significa que os seus artefatos
de implantação estão disponíveis no &lt;em&gt;StorageSVC&lt;/em&gt;, porém não existe nenhuma
réplica/instância da função disponível. Por outro lado, quando uma função está
implantada e existe pelo menos uma réplica da função em execução, então a função
é classificada como &lt;strong&gt;Disponível&lt;/strong&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>fzf - command-line fuzzy finder</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/fzf/</link>
       <pubDate>Wed, 07 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/fzf/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Bruno Roberto Silva de Siqueira.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110854&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:bruno.siqueira@ccc.ufcg.edu.br&#34;&gt;bruno.siqueira@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;https://github.com/junegunn/fzf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----filtro-para-commandline&#34;&gt;Descrição Arquitetural &amp;ndash; Filtro para commandline&lt;/h1&gt;
&lt;p&gt;Este documento - feito através de texto e diagramas aos moldes do &lt;a href=&#34;https://c4model.com&#34;&gt;modelo c4&lt;/a&gt; - descreve o programa para commandline &lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;fzf&lt;/a&gt;, sua interação com o shell, outros programas, e até comunicação com plugins.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Importante destacar que haverá um foco apenas no shell unix.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-fzf&#34;&gt;Descrição Geral sobre o fzf&lt;/h2&gt;
&lt;p&gt;O fzf é um programa utilizado para filtrar informações de um input no shell, de maneira interativa, inclusive com suporte a multiseleção e previews.&lt;/p&gt;
&lt;p&gt;Ao receber uma entrada qualquer de texto, invocado o comando &lt;code&gt;fzf&lt;/code&gt;, o usuário pode digitar uma string qualquer para executar uma busca do tipo &lt;a href=&#34;https://en.wikipedia.org/wiki/Approximate_string_matching&#34;&gt;fuzzy&lt;/a&gt;. Filtradas as linhas relevantes, o usuário poderá selecionar a linha desejada, a qual será devolvida ao shell.&lt;/p&gt;
&lt;p&gt;Apesar de aparentemente simplório, todas as operações acima descritas são completamente customizáveis. É possível utilizar regexes, em vez de fuzzy; selecionar múltiplas linhas; executar operações nas linhas antes de devolvê-las ao shell; expor previews; customizar a exibicão das linhas; dentre várias outras customizações.&lt;/p&gt;
&lt;p&gt;Também, por ser um programa de commandline, operando com strings puras, a integracão com outras ferramentas, via plugins, é bastante fácil de ser implementada via sub processos.&lt;/p&gt;
&lt;p&gt;Dados os pontos acima expostos, o fzf é uma ferramenta bastante poderosa para a commandline. Age em muitos casos como uma interface interativa para alguns programas de commandline, um &lt;em&gt;de facto&lt;/em&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Text-based_user_interface&#34;&gt;TUI&lt;/a&gt;, como para &lt;a href=&#34;https://github.com/bigH/git-fuzzy&#34;&gt;git&lt;/a&gt;, &lt;a href=&#34;https://github.com/ms-jpq/sad&#34;&gt;sed&lt;/a&gt;, &lt;a href=&#34;https://medium.com/@calbertts/docker-and-fuzzy-finder-fzf-4c6416f5e0b5&#34;&gt;docker&lt;/a&gt;, entre outros.&lt;/p&gt;
&lt;h2 id=&#34;a-filtragem-interativa&#34;&gt;A filtragem interativa&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um programa que opere com stdin/stdout, permitindo a busca interativa por linhas relevantes no conteúdo de entrada.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A busca e interface devem ser inteiramente customizáveis, permitindo a utilização &lt;strong&gt;com&lt;/strong&gt; e &lt;strong&gt;por&lt;/strong&gt; outros programas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de contexto e um texto curto descrevendo em mais detalhes o contexto do sistema. Isso inclui as fronteiras do sistema, os sistemas/serviços externos com os quais ele se comunica etc.&lt;/p&gt;
&lt;p&gt;Abaixo estão dois exemplos de diagramas de contexto.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;fzf&lt;/code&gt; é um processo que vive inteiramente no terminal. Este pode ser invocado pelo usuário de diversas formas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Via um pipe, como método de busca e seleção de output: &lt;code&gt;$ comando1 args | fzf | comando2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Diretamente, invocando um comando padrão pré-configurado (por default o &lt;code&gt;find&lt;/code&gt;): &lt;code&gt;$ fzf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Via subprocesso, quando algum outro processo shell quer aproveitar seu mecanismo de busca e seleção (ou diretamente pelo usuário neste modo: &lt;code&gt;$ comando $(fzf)&lt;/code&gt;): &lt;code&gt;kill -9 &amp;lt;tab&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Via integração com o próprio shell, a exemplo do &lt;code&gt;bash&lt;/code&gt; e &lt;code&gt;zsh&lt;/code&gt;: &lt;code&gt;vim **&amp;lt;tab&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;./fzf_context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Por ser uma aplicação shell auto-contida, o &lt;code&gt;fzf&lt;/code&gt; não dispõe de muitos containeres. Apenas podemos dividir a parte gráfica da aplicação, a &lt;em&gt;tui&lt;/em&gt; (&lt;em&gt;terminal user interface&lt;/em&gt;) e sua parte &lt;em&gt;core&lt;/em&gt; - o programa de fato.&lt;/p&gt;
&lt;p&gt;Funcionalidades como argumentos passados pelo usuário, flags, dentre outros, serão geridas pelo &lt;em&gt;core&lt;/em&gt;, via a leitura do comando invocado, em interação direta com o &lt;em&gt;shell&lt;/em&gt;. A &lt;em&gt;tui&lt;/em&gt; apenas desenha gráficos já enviados pelo &lt;em&gt;core&lt;/em&gt;, bem como provê ao usuário feedback para seus filtros, aatual opção selecionada e os previews (enviados prontos pelo &lt;em&gt;core&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./fzf_containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O &lt;code&gt;fzf&lt;/code&gt; conta com três componentes principais dentro do seu core: o &lt;em&gt;Terminal&lt;/em&gt;, &lt;em&gt;Matcher&lt;/em&gt; e o &lt;em&gt;EventBox&lt;/em&gt;, porém há muitos outros instanciados na sua execução.&lt;/p&gt;
&lt;p&gt;Apesar de ser o &lt;em&gt;Terminal&lt;/em&gt; que interpreterá os comandos do usuário, e irá expor comandos de renderização para a &lt;em&gt;tui&lt;/em&gt;, estes são intermediados pelo &lt;em&gt;EventBox&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;em&gt;EventBox&lt;/em&gt; é um componente utilitário que detecta pressionamento de teclas e cliques do usuário na interface gráfica. Os eventos então são observados pelo &lt;em&gt;Terminal&lt;/em&gt; (aqui dito como o componente interno do &lt;code&gt;fzf&lt;/code&gt;), que reage quando algum comando é solicitado por exemplo. Também reage a movimentação do usuário para renderizar novos previews, executar subprocessos, dentre outros.&lt;/p&gt;
&lt;p&gt;Detectadas pressionamentos de teclas &lt;em&gt;char&lt;/em&gt; diretas, é visto que o usuário está executando uma busca, que então é enviada para o &lt;em&gt;Matcher&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;em&gt;Matcher&lt;/em&gt; é quem de fato faz a comunicação com o algoritmo de busca e devolve resultados para a interface, novamente, via eventos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./fzf_components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do OkHttp</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/okhttp/</link>
       <pubDate>Tue, 06 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/okhttp/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;OkHttp&lt;/a&gt;. É importante destacar que não será descrita toda a arquitetura do OkHttp. O foco é a descrição de como é realizado o processo de criação, inicialização e encerramento de uma requisição de rede utilizando os serviços disponibilizados por este projeto.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Adauto Ferreira de Barros Neto.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 114211302&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:adauto.neto@ccc.ufcg.edu.br&#34;&gt;adauto.neto@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;https://github.com/square/okhttp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----cliente-http-para-android&#34;&gt;Descrição Arquitetural &amp;ndash; Cliente HTTP para Android&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;OkHttp&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do OkHttp. O foco aqui é a descrição de um serviço específico de requisições HTTP, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-okhttp&#34;&gt;Descrição Geral sobre o OkHttp&lt;/h2&gt;
&lt;p&gt;HTTP é a maneira que aplicações modernas se comunicam entre si para troca de informações, sendo dados e/ou mídias. Fazer essa conexão da maneira mais eficiente requer bastante esforço, mas traz benefícios tanto de velocidade, como de melhor uso dos recursos disponíveis para a aplicação. O OkHttp é um projeto que implementa um cliente HTTP para Android que busca a eficiência como padrão, sua API de requisições e respostas possui construtores fluidos e imutáveis, suportando chamadas síncronas e assíncronas. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://square.github.io/okhttp/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-cliente-de-requisições-http&#34;&gt;O cliente de requisições HTTP&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um cliente Android eficiente para requisições e respostas HTTP com o interesse em troca de dados e mídia, provendo carregamentos rápidos e economizando larguda de banda.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos ter uma forma eficiente de realizar chamadas HTTP em sistemas Android. Além disso, desejamos o suporte para chamadas síncronas bloqueantes e assíncronas com &lt;em&gt;callbacks&lt;/em&gt;. Também é de interesse do projeto que haja perseverança quando houver conexões problemáticas, se recuperando silenciosamente de problemas comuns de conexão.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema se resume a um cliente de requisições HTTP, que através de uma URL provida pelo usuário, o cliente Android realiza a conexão com um &lt;em&gt;WebServer&lt;/em&gt; que irá conter informações desejadas pela requisição. Essas informações são acessadas por meio da resposta HTTP que pode encapsular diferentes tipos de dados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.jpg&#34; alt=&#34;context&#34;&gt;&lt;/p&gt;
&lt;p&gt;Para o sistema, todo esse processo é nomeado de &lt;strong&gt;call&lt;/strong&gt; e seus estados serão mais detalhados no decorrer deste documento.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A arquitetura do OkHttp no geral se baseia basicamente na divisão de camadas, onde cada uma é responsável por lidar com uma etapa do processo de requisições HTTP. Sendo essas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interface: A camada de interface é responsável pelo recebimento das requisições fornecidas pelo usuário e realiza a inicialização do processo de requisição de rede;&lt;/li&gt;
&lt;li&gt;Protocolo: Camada que executa o processamento da lógica de protocolos, dando suporte a três tipos: HTTP1, HTTP2 e &lt;em&gt;WebSockets&lt;/em&gt;. Definidos dinamicamente através do cliente configurado;&lt;/li&gt;
&lt;li&gt;Conexão: Trata do processo de estabelecimento da conexão com o &lt;em&gt;WebServer&lt;/em&gt; a partir da URL provida pelo usuário, recuperando conexões existentes ou criando novas conexões;&lt;/li&gt;
&lt;li&gt;Cache: Essa camada opera sobre o sistema de cache de requisições. Quando a requisição de rede realizada pelo usuário possui um cache local que atende a requisição, o OkHttp retorna imediatamente o resultado encontrado no cache;&lt;/li&gt;
&lt;li&gt;Entrada/Saída: Responsável pela leitura e escrita de dados. Esta camada depende totalmente do &lt;a href=&#34;https://github.com/square/okio&#34;&gt;Okio&lt;/a&gt;, uma biblioteca que iniciou sendo apenas um componente do OkHttp para realizar o processo de acessar, guardar e processar dados;&lt;/li&gt;
&lt;li&gt;Interceptadores:  A camada de interceptadores contém vários componentes que operam sobre o sistema a qualquer momento, realizando operações lógicas relevantes para o ponto da execução em que foi chamado. Funcionando de forma semelhante a um sistema com programação orientada a aspectos (POA).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;container.jpg&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para esta seção nos apronfudaremos nos componentes da camada de Interface e de Conexão, pois são as que mais agem sobre o sistema e também sobre as &lt;strong&gt;calls&lt;/strong&gt;.&lt;/p&gt;
&lt;h5 id=&#34;interface&#34;&gt;Interface&lt;/h5&gt;
&lt;p&gt;Como dito anteriormente, essa camada é quem realiza a interação com o usuário, recebendo as inforamções necessárias para iniciar a requisição. Ela é composta por, principalmente, 4 componentes que serão descritos abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Call: A call é uma requisição de rede que foi preparada para execução, cada requisição de rede feita pelo usuário será uma &lt;em&gt;call&lt;/em&gt;. Ela pode ser cancelada, mas por se tratar de um par de requisição e resposta, chamado de &lt;strong&gt;stream&lt;/strong&gt;, não pode ser executada mais de uma vez;&lt;/li&gt;
&lt;li&gt;Request: Usada para descrever a requisição que será iniciada. De acordo com as informações providas pelo usuário, esse componente irá encapsular a URL, o método utilizado, cabeçalho e corpo. Também nesse componente é realizado o controle da cache, independente se for uma requisição HTTPS ou não;&lt;/li&gt;
&lt;li&gt;Client: Usuários podem configurar este componente de várias maneiras. Todas as requisições de rede são realizadas através do cliente, cada cliente mantém sua fila de tarefas e seu &lt;em&gt;pool&lt;/em&gt; de conexões, podendo reutilizar conexões que já foram estabelecidas;&lt;/li&gt;
&lt;li&gt;Dispatcher: Esse é o componente que contém a fila de tarefas utilizada pelo Client, mantendo um pool de &lt;em&gt;threads&lt;/em&gt; internamente. Quando uma &lt;em&gt;call&lt;/em&gt; é recebida, o Dispatcher é responsável por encontrar &lt;em&gt;threads&lt;/em&gt; que estejam ociosas e executar com a nova &lt;em&gt;call&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;conexão&#34;&gt;Conexão&lt;/h5&gt;
&lt;p&gt;Essa camada é responsável pela conexão de rede. Aqui também encontramos um &lt;em&gt;pool&lt;/em&gt; de conexões, porém que trata apenas as conexões via &lt;em&gt;socket&lt;/em&gt;. Quando o usuário inicia o processo de requisição de rede, OkHttp vai primeiramente procurar em seu &lt;em&gt;pool&lt;/em&gt; de conexões se existe alguma que atenda aos requisitos. Caso sim, irá enviar requisições diretamente pela conexão que já existe, caso não exista, uma nova conexão é estabelecida para o envio das requisições.&lt;/p&gt;
&lt;p&gt;A partir da introdução de multiplexação completa de solicitação e resposta em HTTP2, o &lt;em&gt;pool&lt;/em&gt; de conexões presente nessa camada busca fazer o mesmo com as conexões via &lt;em&gt;socket&lt;/em&gt;, mantendo várias &lt;strong&gt;RealConnection&lt;/strong&gt; que possibilitam múltiplas requisições de conexões de rede. Com isso, também houve a introdução do &lt;strong&gt;StreamAllocation&lt;/strong&gt; para descrever a carga de requisições. Uma RealConnection representa uma ou mais &lt;em&gt;StreamAllocation&lt;/em&gt;, podendo ser considerado um contador de conexões, quando esse contador alcançar zero, a &lt;em&gt;StreamAllocation&lt;/em&gt; será liberada caso não seja ocupada por novas requisições depois de muito tempo.&lt;/p&gt;
&lt;p&gt;Para a criação de novas conexões, esta camada utiliza o componente de &lt;strong&gt;DNS&lt;/strong&gt; para descobrir o endereço IP do servidor e o &lt;strong&gt;Route&lt;/strong&gt; para testar e selecionar qual deverá ser usado. Após tudo ser definido, irá utilizar o &lt;strong&gt;ConnectionSpec&lt;/strong&gt; para especificar a configuração da conexão &lt;em&gt;socket&lt;/em&gt; em que a requisição HTTP irá ser transportada, em caso de conexão HTTPS, isso também irá incluir a versão TLS e o conjunto de criptografia usada para negociação de conexão segura.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.jpg&#34; alt=&#34;components&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Uma &lt;strong&gt;call&lt;/strong&gt; é o que carrega a requisição HTTP e sua resposta dentro do OkHttp, esse elemento do sistema passa por várias etapas e algumas delas estão descritas abaixo:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Usa a URL que foi provida pelo Android juntamente com o cliente configurado para criar um &lt;strong&gt;endereço&lt;/strong&gt;. Esse endereço é quem especifica como é feita a conexão com o servidor &lt;em&gt;web&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Tenta recuperar uma conexão com esse endereço que já tenha sido utilizada;&lt;/li&gt;
&lt;li&gt;Se não encontrar uma conexão reutilizável, uma rota é selecionada para a tentativa de conexão. Isso significa fazer uma requisição DNS para obter o endereço de IP do servidor;&lt;/li&gt;
&lt;li&gt;Caso seja uma nova rota, ela será conectada utilizando ou SDP, ou túnel TLS (para requisições HTTPS), ou conexão TLS direta. Também faz um TLS handshake.&lt;/li&gt;
&lt;li&gt;Envia a requisição HTTP e lê a resposta.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;info.jpg&#34; alt=&#34;info&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do VS Code</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/vscode/</link>
       <pubDate>Tue, 06 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/vscode/</guid>
       <description>&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;
&lt;img src=&#34;logo-vscode-2.png&#34; style=&#34;border-radius: 80px&#34;/&gt;
&lt;/a&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Gabriel Almeida Azevedo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210009&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:gabriel.almeida.azevedo@ccc.ufcg.edu.br&#34;&gt;gabriel.almeida.azevedo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/microsoft/vscode&#34;&gt;https://github.com/microsoft/vscode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural-do-vs-code&#34;&gt;Descrição Arquitetural do VS Code&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/microsoft/vscode&#34;&gt;VS Code&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do VS Code. O foco aqui é a descrição do seu núcleo central, parte fundamental do projeto. Componentes satélites como o Chrome Debug Core, NLS Tools, CSS/LESS/SCSS Language Service e ESLint possuem seu próprio repositório e não serão abordados profundamente neste documento. Para ver a lista completa de projetos relacionados acesse o link &lt;a href=&#34;https://github.com/microsoft/vscode/wiki/Related-Projects&#34;&gt;Related Projects&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-vs-code&#34;&gt;Descrição Geral sobre o VS Code&lt;/h2&gt;
&lt;p&gt;O Visual Studio Code, ou simplesmente VS Code, é um editor de código que foi lançado em 2015 pela Microsoft. É uma ferramenta de código aberto voltada para o desenvolvimento de aplicações web, mobile e de cloud. O Visual Code se baseia no Electron (framework usada para desenvolver aplicativos Node.js). O seu conjunto de utilitários faz com que ele concorra de igual para igual com ferramentas pagas existentes no mercado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seus pontos de Destaque são:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;É Multiplataforma;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;multiplataforma.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;É Multilinguagem: Suporta mais de 30 linguagens de programação além de formatos comuns de arquivos;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;É Personalizável;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;É uma aplicação leve;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apresenta uma excelente paleta de atalhos: além da seus atalhos, é possível alterar para os atalhos reconhecidos pelo Sublime e pelo Atom;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Permite adicionar extensões;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Possui o IntelliSense: Recurso de preenchimento de código que permite listar métodos, obter informações de parâmetros, completar palavras.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;intelliSense.gif&#34; alt=&#34;intelliSense&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral-do-vs-code&#34;&gt;Objetivo Geral do VS Code&lt;/h3&gt;
&lt;p&gt;Fornecer um editor de código simples que cubra as necessidades dos desenvolvedores nas 3 fases de desenvolvimento: codificação, criação do artefato e depuração.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Prover uma ferramenta poderosa para o desenvolvedor, que tenha uma edição de código abrangente, navegação e suporte de compreensão, depuração leve, um modelo de extensibilidade rico e integração leve com ferramentas existentes.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O VS Code é uma aplicação que roda em sistemas windows, macOS e Linux. Esta aplicação tem como base para sua UI(interface de usuário), o framework Electron, e interage com o sistema de versionamento do &lt;strong&gt;&lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-contexto-vscode-plat.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Através da API de extensões é possível customizar todo o VS Code. Os serviços de linguagem e de depuração são tratados como uma classe especial de Extensões.&lt;/p&gt;
&lt;p&gt;O serviço de Linguagens é dividido em 2 partes: o client (extensão VS Code) escrito em JavaScript/TypeScript e o Server (ferramenta de análise de linguagem executada em um processo separado). O Client cria uma instância do Server da linguagem correspondente e se comunica através do LSP. Este serviço permite a experiência de edição para muitas linguagens de programação. Pode-se implementar autocomplete, verificação de erros (diagnóstico), salto para definição e muitos outros recursos de linguagem suportados no VS Code.&lt;/p&gt;
&lt;p&gt;Com o serviço de depuração os autores de extensão podem integrar facilmente depuradores ao VS Code. O VS Code provê uma interface de usuário comum à todos eles.&lt;/p&gt;
&lt;p&gt;A interface de versionamento de arquivos permite criar/trocar de branch, adicionar/remover arquivos à um commit, solucionar conflitos, atualizar a branch remota, entre outras funcionalidades.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers-vscode-2.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Vale salientar que o VS Code é uma aplicação grande. Foi escolhido apenas 2 containers para serem expandidos e, ainda assim, só uma amostra dos seus componentes está no diagrama.&lt;/p&gt;
&lt;p&gt;Abrindo o container de Extensões tem-se como principais componentes o &lt;em&gt;Extension Gallery Service&lt;/em&gt; que provê a listagem de extensões disponíveis para usuário juntamente com suas descrições e changelogs. A partir dessa listagem o usuário pode escolher fazer o download de uma extensão. O componente responsável por este papel é o &lt;em&gt;Extension Downloader&lt;/em&gt; que baixa a extensão desejada e repassa os arquivos para o &lt;em&gt;Extension Management Service&lt;/em&gt; que por sua vez tem a responsabilidade de averiguar se a extensão é confiável, realizar sua instalação e registro.&lt;/p&gt;
&lt;p&gt;O container do Editor possui vários componentes mas sem dúvida o &lt;em&gt;Text Change&lt;/em&gt; faz parte do seu núcleo. Ele é responsável por realizar toda e qualquer alteração nos arquivos e interage fortemente com o componente &lt;em&gt;Diff Computer&lt;/em&gt;. Ambos componentes são utilizados pelo versionador do VS Code. Existe ainda o &lt;em&gt;Cursor Delete Operations Controller&lt;/em&gt; e o &lt;em&gt;Find Controller&lt;/em&gt; que invocam o &lt;em&gt;Text Change&lt;/em&gt; para realizar as alterações/remoções de código.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes-vscode.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O container responsável pela parte de edições e versionamento de arquivos é o &lt;em&gt;Editor&lt;/em&gt;.&lt;br&gt;
Para o diagrama de estados de um &lt;em&gt;Arquivo&lt;/em&gt; no VS Code, tem-se 3 possibilidades iniciais: criar um arquivo, editar um arquivo ou ainda remover um arquivo.&lt;/p&gt;
&lt;p&gt;Pontos que devem ser mencionados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ao criar um arquivo e definir sua extensão o VS Code invoca o Serviço de Linguagens para verificar se já existe em seu ambiente uma conexão com o server da extensão do arquivo criado;&lt;/li&gt;
&lt;li&gt;Ao editar um arquivo, pode-se alterar o código manualmente, usar atalhos de cursor, o que envolve seus respectivos controllers (ex: Cursor Delete Operations Controller) e o find/replace. Cada um desses modos invocará o componente &lt;em&gt;Text Change&lt;/em&gt; para efetivar a mudança;&lt;/li&gt;
&lt;li&gt;Sempre que tenta-se excluir um arquivo que está aberto ou em raschunho, o VS Code pergunta se essa ação deverá ser realmente realizada, se sim, ele exclui o arquivo e fecha sua janela de edição;&lt;/li&gt;
&lt;li&gt;Pode-se, ou não, usar o VS Code para versionar seu arquivo. Isto é feito através do componente &lt;em&gt;Versionador&lt;/em&gt; (trata questões de branch, diffs, commits, conflitos, pull/pushs e merges) que se integra ao &lt;strong&gt;GitHub&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-informacao-vscode.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Até o presente momento ainda não foi aberto nenhum pull request desta documentação para o &lt;a href=&#34;https://github.com/microsoft/vscode-docs/&#34;&gt;repositório&lt;/a&gt; de docs do VS Code.&lt;/em&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural para o Comunidades.tech</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/comunidadestech/</link>
       <pubDate>Mon, 05 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/comunidadestech/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autora&#34;&gt;Autora&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Raquel Ambrozio da Fonseca.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210531&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:raquel.fonseca@ccc.ufcg.edu.br&#34;&gt;raquel.fonseca@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/universoimpulso/comunidadestech&#34;&gt;https://github.com/universoimpulso/comunidadestech&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----comunidadestech&#34;&gt;Descrição Arquitetural &amp;ndash; Comunidades.tech&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura de parte do sistema &lt;a href=&#34;https://github.com/universoimpulso/comunidadestech&#34;&gt;Comunidades.tech&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que será considerado apenas as principais funcionlidades do Comunidades.tech, ou seja, elementos específicos do sistema e suas implementações não serão detalhados.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-comunidadestech&#34;&gt;Descrição Geral sobre o Comunidades.tech&lt;/h2&gt;
&lt;p&gt;O Comunidades.tech é um projeto open source desenvolvido pela comunidade da &lt;a href=&#34;https://impulso.network/entrar?referral=comunidadestech&#34;&gt;Impulso.Network&lt;/a&gt;, que tem como objetivo ser um espaço de visibilidade e fortalecimento das comunidades de tecnologia. O sistema pode ser acessado &lt;a href=&#34;https://comunidades.tech/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;comunidadestech&#34;&gt;Comunidades.tech&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um sistema para divulgar comunidades nacionais relacionadas a tecnologia, sendo essas vituais ou presenciais.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos cadastrar e publicar comunidades de tecnologia, levando em consideração suas principais caracteríticas, como tipo (Discord, Meetup, Slack, etc) e categoria (Desenvolvimento de Software, Infraestrutura, Dados, Games, etc ). Por fim, disponibilizar essas comunidades em um catálogo com seus devidos dados, para que as pessoas consigam encontrar (utilizando os filtros) comunidades de seu interesse de maneira rápida e prática.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema Comunidades.tech utiliza a API do LinkedIn como login para manter o cadastro e fazer a autenticação do usuário. Esse &lt;strong&gt;usuário&lt;/strong&gt; pode ser classificado nas seguintes categorias:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pessoa que representa uma ou mais comunidades&lt;/strong&gt; e deseja cadastrar e divulgar sua(s) comunidade(s);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pessoa que quer participar de comunidade(s)&lt;/strong&gt; e deseja buscar e visualizar comunidades do seu interesse;&lt;/li&gt;
&lt;li&gt;Ambos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As informações das comunidades cadastradas são maninpuladas pelo Back-end do sistema Comunidades.tech, e armazenadas em um Banco de Dados mantido pelo mesmo.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OBS&lt;/strong&gt;: Além do LinkedIn, também pode ser utilizada uma conta do Google para realizar o cadastro do usuário, mas, por questões de simplificação, esse detalhe não foi ilustrado.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O sistema Comunidades.tech é uma aplicação que pode ser dividida basicamente em três grandes partes (containers):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O &lt;strong&gt;Front-end&lt;/strong&gt; (implementado utilizando React.JS): é a parte que o usuário interage através do seu navergador web para acessar as funcionalidades do sistema;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;Back-end&lt;/strong&gt; (implementado utilizando Node.JS): é responsável pela lógica de negócios;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Banco de Dados&lt;/strong&gt; (MongoDB): onde os dados sobre os usuários e as comunidades cadastradas/publicadas são armazenados;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Abaixo está o diagrama de containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Os &lt;strong&gt;containers&lt;/strong&gt; estão &lt;strong&gt;executando/implantandos&lt;/strong&gt; na plataforma em núvem &lt;strong&gt;Heroku&lt;/strong&gt;. E toda comunicação é feita via API-REST em formato JSON utilizando protocolos HTTPS.&lt;/p&gt;
&lt;p&gt;Alguns serviços da API são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adicionar uma comunidade cadastrada;&lt;/li&gt;
&lt;li&gt;Recuperar informações de uma comunidade cadastrada;&lt;/li&gt;
&lt;li&gt;Deletar uma comunidade cadastrada.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Os principais componentes da API do sistema Comunidades.tech estão descritos a seguir:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Login&lt;/strong&gt;: componente responsável pelo login dos usuários no sistema;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Segurança&lt;/strong&gt;: componente responsável por funcionalidades relacionadas ao login, mudança de senhas, etc;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cadastro de Usuário&lt;/strong&gt;: componente responsável pelo cadastro de um usuário no sistema;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cadastro de Comunidade&lt;/strong&gt;: componente responsável pelo cadastro de uma comunidade;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Edição dos Dados da Comunidade&lt;/strong&gt;: componente responsável pela atualização dos dados das comunidades cadastradas pelo usuário;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dashboard&lt;/strong&gt;: componente responsável pela vizualização de todas as comunidades cadastradas do usuário.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A seguir está o diagrama de componentes ilustrando os componentes supracitados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-componentes.svg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O objetivo do sistema é divulgar comunidades, por isso, entender o fluxo das informações relacionadas com o procedimento de cadastro até a divulgação dessas comunidades é muito importante.&lt;/p&gt;
&lt;p&gt;O primeiro passo para conseguir publicar uma comunidade é fazer parte do Comunidades.tech, ou seja, ter um cadastrado ativo no sistema. Após o login, é possível visualizar um botão &amp;ldquo;Casdastre uma comunidade&amp;rdquo;, clicando nele, será aberta a página de cadastro com alguns formulários que solicitam informações como: nome, localização, membros e links. Após o preenchimento dos quatro formulários, e concluída a revisão dos dados preenchidos, basta clicar no botão &amp;ldquo;Criar Comunidade&amp;rdquo;, e acomunidade será cadastrada. Logo pós o cadastro, automaticamente a comunidade será encaminhada para análise, onde  ocorre a validação dos dados. Finalmente, a depender do resultado da análise, a comunidade será aprovada e publicada no catálogo de comunidades.&lt;/p&gt;
&lt;p&gt;A seguir está o diagrama de máquina de estados para descrever os estados do procedimento de publicação de uma comunidade.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-maquina-estados.jpeg&#34; alt=&#34;fig&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Para a realização de contribuições acessei o repositório onde está localizado o projeto Comunidades.tech, fiz o fork do projeto, clonei o reposítório, criei uma branch chamada architectural-documentation. Na raiz do projeto, criei um arquivo Markdown chamado architectural-documentationn e uma pasta (com o mesmo nome) para armazenar as imagens utilizadas no Markdown. Por fim, copiei, colei e salvei o conteúdo desse documento (exceto as seções código e contribuições concretas) no arquivo criado. Fiz o commit, o push e realizei o pull request. O pull request pode ser visualizado &lt;a href=&#34;https://github.com/universoimpulso/comunidadestech/pull/247&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Após revisão do código enviado, foi solicitado que fosse alterado o modo de contato (que estava com um e-mail acadêmico), para o link do meu perfil no GitHub. Logo depois que a alteração foi concluída e submetida, o &lt;strong&gt;pull request foi aceito&lt;/strong&gt; (16/10/2020).&lt;/p&gt;
&lt;h1 id=&#34;referências&#34;&gt;Referências&lt;/h1&gt;
&lt;p&gt;Todo conteúdo desse documento foi baseado no estudo do código do repositório do projeto, juntamente com informações adicionais adquiridas através de integrantes da &lt;a href=&#34;https://impulso.network/entrar&#34;&gt;comunidade da Impulso Network&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação da arquitetura do navegador Brave</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/brave-browser/</link>
       <pubDate>Sun, 04 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/brave-browser/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Luiggy Ferreira Dias Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117211159&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:luiggy.silva@ccc.ufcg.edu.br&#34;&gt;luiggy.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/brave/brave-core&#34;&gt;https://github.com/brave/brave-core&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----navegador-brave&#34;&gt;Descrição Arquitetural &amp;ndash; Navegador Brave&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do navegador &lt;a href=&#34;https://github.com/brave/brave-core&#34;&gt;Brave&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-navegador-brave&#34;&gt;Descrição Geral sobre o navegador Brave&lt;/h2&gt;
&lt;p&gt;O Brave é um navegador que tem como principal diferencial o pagamento de tokens aos usuários que visualizam as propagandas definidas pelo navegador utilizando uma moeda própria por meio da blockchain, além disso, possui um bloqueador de anúncios e rastreadores nativos que propõem mais privacidade ao usuário.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Brave é um navegador de internet que conta com um bloqueador de rastreadores e anúncios integrados e um sistema de recompensa para os usuários que visualizam suas propragandas (privadas). Essa recompensa é entregue via uma &lt;a href=&#34;https://basicattentiontoken.org/&#34;&gt;moeda virtual&lt;/a&gt; própia do navegador, e para armazenar essa moeda o navegador oferece uma conta no sistema financeiro da &lt;a href=&#34;https://uphold.com/pt/homepage&#34;&gt;Uphold&lt;/a&gt; que trabalha com criptomoedas e as principais moedas do mundo. O Brave também tem integrado o sitema da exchange &lt;a href=&#34;https://www.binance.com/en&#34;&gt;Binance&lt;/a&gt;, permitindo compra, venda de ativos e a verificação de saldos diretamente de um widget oficial dentro do navegador. O Brave também oferece nativamente a opção de usar o buscador &lt;a href=&#34;https://duckduckgo.com/about&#34;&gt;DuckDuckGo&lt;/a&gt; fruto de uma parceria com o sistema.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Brave pode ser utilizado na sua versão Desktop e também em sua versão Mobile, compartilhando das principais funcionalidades. Ambas versões possuem um database para armazenar os dados do navegador.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O diagrama acima contém os principais componentes do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Browser:&lt;/em&gt; Responsável pela funcionalidade principal de possibilitar o acesso a internet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Search_Engines:&lt;/em&gt; Responsável por disponibilizar os buscadores para o Brave. Esse componente que se relaciona com o buscador parceiro do Brave, o &lt;a href=&#34;https://duckduckgo.com/about&#34;&gt;DuckDuckGo&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Binance:&lt;/em&gt; Responsável por se conectar com o sistema externo da Exchange &lt;a href=&#34;https://www.binance.com/en&#34;&gt;Binance&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Brave_Ads:&lt;/em&gt; Responsável por gerenciar as propagandas do navegador.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Brave_Rewards:&lt;/em&gt; Responável por gerenciar as recompensas pelas visualizações das propagandas do Brave. Esse componente se relaciona com o sistema da &lt;a href=&#34;https://uphold.com/pt/homepage&#34;&gt;Uphold&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Brave_Shields:&lt;/em&gt; Responsável por bloquear anúncios e rastreadores dos sites que o usuário visita.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-maquina_de_estados_extens%C3%B5es.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;A máquina de estados acima representa os possíveis estados que as &lt;em&gt;extensões&lt;/em&gt; do navegador podem assumir. Uma &lt;em&gt;extensão&lt;/em&gt;, após ser instalada, é automaticamente habilitada e o usuário pode desabilitar ou desinstalar a extensão.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Serenata de Amor - Documentação arquitetural </title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/serenata-de-amor/</link>
       <pubDate>Sun, 04 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/serenata-de-amor/</guid>
       <description>&lt;hr&gt;
&lt;img src=&#34;./logo.png&#34; style=&#34;width: 50%; display: flex; margin: 0 auto;&#34;/&gt;
&lt;p&gt;Projeto de auditoria automática para a cota de auxílio parlamentar de reembolsos para gastos.&lt;/p&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Nicácio Oliveira de Sousa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115111897&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:nicacio.sousa@ccc.ufcg.edu.br&#34;&gt;nicacio.sousa@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/okfn-brasil/serenata-de-amor&#34;&gt;https://github.com/okfn-brasil/serenata-de-amor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/okfn-brasil/serenata-de-amor&#34;&gt;Serenata de Amor&lt;/a&gt; e tem como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que este documento visa expor de forma mais abstrata como funciona o conjunto de ferramentas da aplicação e não necessariamente explicará em detalhes a sua implementação.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-serenata-de-amor&#34;&gt;Descrição Geral sobre o Serenata de Amor&lt;/h2&gt;
&lt;p&gt;O serenata de amor é um projeto que visa &lt;a href=&#34;https://brasil.elpais.com/brasil/2017/01/23/politica/1485199109_260961.html&#34;&gt;auditar gastos públicos&lt;/a&gt; relacionados a cota de auxílio parlamentar a qual é utilizada pelos parlamentares para requerirem reembolsos dos gastos que são relacionados a função parlamentar. Um reembolso pela cota parlamentar pode ser requerido para qualquer tipo de atividade do parlamentar como o gasto com alimentação, passagens aéreas, combustível, aluguéis, assinaturas etc.&lt;/p&gt;
&lt;p&gt;A função de auditar a veracidade dos pedidos de reembolso pode ser uma tarefa inumana pela quantidade de pedidos todos os meses e a quantidade de variáveis envolvidas. O Serenata de Amor automatiza esse procedimento de auditoria para criar alertas sobre notas fiscais com valores duvidosos e auxiliar esse trabalho de forma muito mais barata e rápida.&lt;/p&gt;
&lt;h4 id=&#34;mas-como-isso-é-feito&#34;&gt;Mas como isso é feito?&lt;/h4&gt;
&lt;p&gt;O projeto possui dois grandes módulos. Um &lt;a href=&#34;https://twitter.com/RosieDaSerenata&#34;&gt;(Rosie)&lt;/a&gt; para auditar notas fiscais de pedidos de reembolsos e outro &lt;a href=&#34;https://jarbas.serenata.ai/&#34;&gt;(Jarbas)&lt;/a&gt; para listar os dados auditados de forma fácil.&lt;/p&gt;
&lt;p&gt;Em geral, um usuário precisa acionar a Rosie para que, com base em dados anteriores e já avaliados, ela classifique dados entregues pelo governo federal a cada mês e em seguida insira o conjunto de dados classificados no banco de dados do Jarbas para que ele exiba-os e também crie alertas no twitter sobre casos suspeitos.&lt;/p&gt;
&lt;h4 id=&#34;rosie&#34;&gt;Rosie&lt;/h4&gt;
&lt;p&gt;Robô que tem sua construção baseada na &lt;a href=&#34;https://github.com/okfn-brasil/serenata-toolbox&#34;&gt;toolbox do serenata de amor&lt;/a&gt;.
A Rosie faz auditoria em notas fiscais que são cadastradas na base de dados do governo federal e classifica cada nota com uma flag de suspeita ou não.&lt;/p&gt;
&lt;p&gt;A classificação das notas é feita com base em diversas de variáveis como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gastos exagerados com alimentação, combustível, passagens etc&lt;/li&gt;
&lt;li&gt;Estar em dois lugares ao mesmo tempo&lt;/li&gt;
&lt;li&gt;Valores exorbitantes em localidades que cobram um valor diferente do que a nota fiscal diz&lt;/li&gt;
&lt;li&gt;Valores superfaturados&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O processo, em uma visão modular, é simples. A Rosie é alimentada com dados previamente classificados em mêses e anos anteriores, é feito um treinamento em um modelo para que ele seja utilizado para classificar dados futuros.&lt;/p&gt;
&lt;h4 id=&#34;jarbas&#34;&gt;Jarbas&lt;/h4&gt;
&lt;p&gt;Painel de controle que exibe os dados auditados pela Rosie de forma organizada.
O Jabas também é responsável por criar posts de alerta no twitter, indicando pedidos de reembolso suspeitos.&lt;/p&gt;
&lt;h2 id=&#34;serviço-de-auditoria-de-cotas-parlamentares&#34;&gt;Serviço de auditoria de cotas parlamentares&lt;/h2&gt;
&lt;h3 id=&#34;objetivo&#34;&gt;Objetivo&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que possa auditar notas fiscais cadastradas na base de dados do governo federal que sejam relacionadas a cota de gastos parlamentares e relacionar cada nota à variáveis que indiquem se cada uma delas é suspeita de fraude ou não.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Treinar modelos, com base em dados auditados anteriormente, para classificação de cada nota fiscal que for utilizada para pedidos de reembolso para indicar se cada nota pode ser considerada suspeita e interagir em rede social criando alertas sobre gastos suspeitos através do módulo Jarbas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;A comunicação e contexto gerais dos sitema acontecem entre os dois elementos principais (Rosie e Jarbas) em conjunto com a publicação de mensagens com alertas no twitter.&lt;/p&gt;
&lt;p&gt;Os dados devem ser lidos da base de dados do governo federal referente a dados de cota parlamentar. Em seguida, a Rosie deve ser ativada para classificar os dados de acordo com as regras que conhece e indicar se a nota fiscal atrelada ao pedido de reenbolso é suspeita. Por fim, o banco de dados do Jarbas deve ser alimentado com os novos dados classificados pela Rosie e então o Jarbas irá lista-los e criar posts de tempos em tempos para todas as suspeitas encontradas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.svg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A Rosie é constituída por um conjunto de classificadores de notas fiscais de pedidos de reembolso. É basicamente um módulo python que utiliza Scikit para criar classificadores.&lt;/p&gt;
&lt;p&gt;Classificadores:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Despesas eleitorais&lt;/li&gt;
&lt;li&gt;Empresas irregulares no lançamento das notas fiscais&lt;/li&gt;
&lt;li&gt;Despesas com refeições&lt;/li&gt;
&lt;li&gt;Limite de subcota parlamentar mensal&lt;/li&gt;
&lt;li&gt;Gastos com combustível&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Em uma visão mais detalhada dos containers, podemos entender como se dá a comunicação dos dois módulos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers-rosie-jarbas.svg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;A implantação do sistema é feita em &lt;a href=&#34;https://www.digitalocean.com/products/droplets/&#34;&gt;Droplets da Digital Ocean&lt;/a&gt; e não há muitos detalhes aqui a não ser observar os arquivos de configuração docker-compose que definem quais serviços serão instanciados no Droplet da Digital Ocean.&lt;/p&gt;
&lt;p&gt;Apenas o jarbas deve permanece online 24 horas por dia. Por simplicidade, a Rosie é acionada apenas algumas vezes ao mês de forma manual e a base de dados do Jarbas é atualizada com os dados novos também manualmente.&lt;/p&gt;
&lt;p&gt;O Jarbas é apenas um dashboard que expõe os dados classificados e que não chegam na casa dos milhões. Logo, a arquitetura de implantação deve-se manter simples pois traz baixo custo e facilidade de implantação.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;A Rosie utiliza como base o conjunto de ferramentas da Toolbox e é organizada em pacotes relativos a cada tipo de classificação que será feita.
No momento atual, a câmara dos deputados é o principal ponto de análise e todos os outros módulos que venham a ser criados devem seguir o mesmo padrão, então vamos focar apenas no módulo de classificação da câmara dos deputados.&lt;/p&gt;
&lt;p&gt;Cada pacote de classificadores utiliza o sklearn para treinar um modelo utilizando como base dados que foram classificados e resolvidos anteriormente. Assim, quanot mais o tempo passar, cada vez mais a Rosie irá criar modelos para classificação mais aprimorados.&lt;/p&gt;
&lt;p&gt;A Visão mais abstrata dos componentes da Rosie pode ser visualizada em seguida:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes-rosie.svg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Jarbas, por simplicidade é apenas um serviço Python-Django que lê a lista de dados de reembolso e expõe uma ai simples para busca e filtro dessa listagem.
Além de sua função de listagem e filtro, o jarbas cria posts no twitter para denunciar pedidos que estejam classificados como suspeitos e marca-os como denunciados.&lt;/p&gt;
&lt;p&gt;O único caso particular que teremos aqui é a limitação da quantidade de posts por hora da api do Twitter que é utilizada pelo jarbas. Há um &lt;a href=&#34;https://developer.twitter.com/en/docs/twitter-api/v1/rate-limits#:~:text=Standard%20API%20v1.&amp;amp;text=You%20can%20only%20post%20300,id%20endpoint%20during%20that%20period.&#34;&gt;limite&lt;/a&gt; e ele é considerado na criação dos posts.&lt;/p&gt;
&lt;p&gt;Cada dado de reembolso carrega a informação do ID do requerente e links para detalhes que são apontados para o sistema do governo federal.&lt;/p&gt;
&lt;p&gt;A API exposta pelo Jarbas é apenas uma rota com opcionais de filtragem para visualização dos dados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET /api/chamber_of_deputies/reimbursement/&amp;lt;document_id&amp;gt;/receipt/&lt;/li&gt;
&lt;li&gt;GET /api/chamber_of_deputies/reimbursement/&amp;lt;document_id&amp;gt;?&lt;filtros&gt;&lt;/li&gt;
&lt;li&gt;GET /api/chamber_of_deputies/reimbursement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Os filtros em forma de query que podem ser utilizados podem ser visualizados no &lt;a href=&#34;https://github.com/okfn-brasil/serenata-de-amor/tree/main/jarbas#json-api-endpoints&#34;&gt;repositório oficial do projeto&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Os componentes do jarbas são os seguintes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes-jarbas.svg&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;As informações mais importantes para o funcionamento do Serenata de Amor são basicamente todas as informações ligadas à um pedido de reembolso:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pedido de Reembolso&lt;/li&gt;
&lt;li&gt;Nota Fiscal&lt;/li&gt;
&lt;li&gt;Empresa (CNPJ, Endereço etc)&lt;/li&gt;
&lt;li&gt;Parlamentares&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Abaixo podemos entender alguns pontos idispensáveis para a compreensão do uso da informação no sistema.&lt;/p&gt;
&lt;h4 id=&#34;dados-de-estabelecimentos-com-localização-e-dados-relacionados-ao-cadastro-de-pessoa-jurídica-no-governo-federal&#34;&gt;Dados de estabelecimentos com localização e dados relacionados ao cadastro de pessoa jurídica no governo federal.&lt;/h4&gt;
&lt;p&gt;A Rosie precisa entender qual tipo de estabelecimento, se ele está cadastrado na base de dados do governo federal e qual a região onde se localiza para aprender sobre qual valor de despesa é considerado normal.&lt;/p&gt;
&lt;h4 id=&#34;dados-de-cada-parlamentar-ligado-a-cada-pedido-de-reembolso&#34;&gt;Dados de cada parlamentar ligado a cada pedido de reembolso&lt;/h4&gt;
&lt;p&gt;Além da importâcia de entender qual o parlamentar requerente, é interessante que o Jarbas conheça esse dado para criar alertas e faça associação ao parlamentar no twitter.&lt;/p&gt;
&lt;h4 id=&#34;dados-que-foram-auditados-anteriormente&#34;&gt;Dados que foram auditados anteriormente&lt;/h4&gt;
&lt;p&gt;Para o passo inicial do sistema a Rosie necessita de um conjunto de dados previamente classificados/auditados que indique os dois estados de um pedido de reembols. Logo, os dados gerados até o momento do iníio da rosie servem de base de treinamento para o modelo de classificação e posteriormente serão somados a esse conjunto de dados os dados auditados pela prória Rosie para continuar aumentando a acurácia das classificações da Rosie.&lt;/p&gt;
&lt;h4 id=&#34;fluxo-da-informação-no-jarbas-para-postagem-de-alertas-no-twitter&#34;&gt;Fluxo da informação no Jarbas para postagem de alertas no twitter&lt;/h4&gt;
&lt;p&gt;Por mais que seja simples, um diagrama de estados nos ajuda a manter claro como isso deve ser feito no twitter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;fluxo-de-alerta-jarbas.svg&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Jenkins</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/jenkins/</link>
       <pubDate>Fri, 02 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/jenkins/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Cássio Cordeiro.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210038&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:cassio.cordeiro@ccc.ufcg.edu.br&#34;&gt;cassio.cordeiro@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/jenkinsci/jenkins&#34;&gt;https://github.com/jenkinsci/jenkins&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do &lt;a href=&#34;https://github.com/jenkinsci/jenkins&#34;&gt;Jenkins&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição&#34;&gt;Descrição&lt;/h2&gt;
&lt;p&gt;O Jenkins é projeto focado em ser expansível às necessidades dos usuários, contendo um vasto acervo de plugins criados e permitindo configurações personalizadas, suas principais usos são para atividades de  CI (continuous integration) e CD (continuous delivery). Ele automatiza as partes do processo de desenvolvimento de software relacionadas ao build, testes, deploy e entrega. Outras informações podem ser encontradas no site oficial do sistema.&lt;/p&gt;
&lt;h3 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h3&gt;
&lt;p&gt;Oferecer um serviço que seja customizável e expansível aos requisitos dos projetos e de cada usuário, automatizando tarefas repetitivas no processo de desenvolvimento de software.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Os principais sistemas que o Jenkins se comunica são seus plugins, que quando instalados, acrescentam mais funcionalidades ao sistema e a possibilidade de comunicação com outros sistemas; o Git, podendo realizar processos com projetos hospedados nele; e serviços de comunicação, sendo capaz de enviar mensagens, contento, principalmente, o resultado de operações de build.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O sistema é composto basicamente por dois containers: a interface web e a aplicação (API). O primeiro, possibilita interação com o usuário, é feito usando Jelly e renderizado do lado do servidor. Já o segundo, gerencia toda a parte de projetos, de dados e comunicação externa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Abaixo estão alguns exemplos de como são processados os paths:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get: /log/… → Jenkins#getLog()
&lt;ul&gt;
&lt;li&gt;Busca o arquivo log do sistema.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Get com argumentos: /job/foo/… → Hudson#getJob(“foo”)
&lt;ul&gt;
&lt;li&gt;Busca um job chamado foo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Get dinâmico: /job/foo/1/… → Job#getDynamic(“1” &amp;hellip;)
&lt;ul&gt;
&lt;li&gt;Busca o build 1 do job foo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Método de ação: /job/foo/1/artifact → Run#doArtifact(&amp;hellip;)
&lt;ul&gt;
&lt;li&gt;Executa o método doArtifact no build 1 do job foo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quanto à implantação, o Jenkins pode ser instalado em qualquer máquina. Ele possui compatibilidade com os principais sistemas operacionais, Linux, MacOS e Windows, além de poder ser instalado usando o Docker ou na nuvem.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O sistema é composto por 6 componentes principais:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Componente de segurança: seu principal papel é prover autenticação e controle de acesso aos recursos. Ele recebe do gerenciador de usuários as informações necessárias para prover seus serviços.&lt;/li&gt;
&lt;li&gt;Gerenciador de usuários: realiza todo o controle de usuário, como cadastro, atualização e controle de permissões. Os dados são lidos e escritos usando o controlador de dados.&lt;/li&gt;
&lt;li&gt;Gerenciador de plugins: controla tudo relacionado aos plugins.&lt;/li&gt;
&lt;li&gt;Gerenciador de projetos: responsável pelo gerenciamento das ações relacionadas aos projetos, por conectar com o git e enviar notificações.&lt;/li&gt;
&lt;li&gt;Controlador de dados: escreve e lê os dados do sistema de arquivos, utilizando o XStream. Fornece dados para outros componentes.&lt;/li&gt;
&lt;li&gt;Componente de estatísticas: utiliza o histórico das builds dos projetos para criar estatísticas e indicar tendências.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Todas as informações giram em torno dos projetos. Os usuários recebem permissões para visualizar, editar e realizar ações neles. Durante o build são executadas as pipelines, caso ocorra algum erro, a build entra no estado de erro, caso contrário, de sucesso. Cada resultado é armazenado no histórico e utilizado para gerar informações estatísticas dos projetos.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Instruções para escrever o post</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/instrucoes/</link>
       <pubDate>Tue, 07 Apr 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/instrucoes/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Por favor, leia com cuidado as instruções abaixo.&lt;/p&gt;
&lt;h1 id=&#34;o-que-você-deve-produzir&#34;&gt;O que você deve produzir?&lt;/h1&gt;
&lt;p&gt;Um documento de descrição arquitetural. &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog/posts/documento-guia/&#34;&gt;Neste link&lt;/a&gt; estão as instruções sobre formato e sobre o que é preciso em cada seção do documento. Por favor, mantenha o formato que estabeleci.&lt;/p&gt;
&lt;h1 id=&#34;como-escrever-o-documento&#34;&gt;Como escrever o documento?&lt;/h1&gt;
&lt;p&gt;Você vai escrever em Markdown, que é uma linguagem simples de marcação. Não se preocupe se não souber a sintaxe, pois você pode, por exemplo, basear a escrita no Markdown que gerou este post (&lt;a href=&#34;https://raw.githubusercontent.com/joaoarthurbm/arqsoft-blog/master/content/posts/documento-guia.md&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Markdown é bem simples de entender e há muito material sobre markdown na web.&lt;/p&gt;
&lt;h1 id=&#34;onde-escrever&#34;&gt;Onde escrever?&lt;/h1&gt;
&lt;p&gt;Nós vamos usar este repositório: &lt;a href=&#34;https://github.com/joaoarthurbm/arqsoft-blog&#34;&gt;https://github.com/joaoarthurbm/arqsoft-blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Você terá que submeter o markdown (e as figuras que produziu) como Pull Requests.&lt;/p&gt;
&lt;p&gt;Este pull request que você fará, será revisado por mim e, quando aceito, automaticamente vira um post em &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog/&#34;&gt;https://joaoarthurbm.github.io/arqsoft-blog/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;como-fazer&#34;&gt;Como fazer?&lt;/h1&gt;
&lt;h2 id=&#34;pré-quisitos&#34;&gt;Pré-quisitos&lt;/h2&gt;
&lt;p&gt;Você precisa instalar o hugo na sua máquina. Veja este link: &lt;a href=&#34;https://gohugo.io/getting-started/installing/&#34;&gt;https://gohugo.io/getting-started/installing/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;passo-a-passo&#34;&gt;Passo a passo&lt;/h2&gt;
&lt;h3 id=&#34;setup-gitgithub&#34;&gt;Setup git/github&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Faça um fork do projeto &lt;a href=&#34;https://github.com/joaoarthurbm/arqsoft-blog&#34;&gt;https://github.com/joaoarthurbm/arqsoft-blog&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Faça clone do repositório e dos submodulos &lt;a href=&#34;https://github.com/SEU-USUARIO/arqsoft-blog/&#34;&gt;https://github.com/SEU-USUARIO/arqsoft-blog/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone --recurse-submodules https://github.com/SEU-USUARIO/arqsoft-blog.git&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crie uma branch cujo nome será o seu login @ccc&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch NOME.SOBRENOME&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mude para a branch que você acabou de criar&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout NOME.SOBRENOME&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;produzindo-conteúdo&#34;&gt;Produzindo conteúdo&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Entre na pasta &lt;code&gt;content/posts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd content/posts&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nesta pasta estarão os documentos de vocês. Aqui você deve criar um arquivo e um diretório:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O markdown do seu documento.
Use o nome do projeto que você está documentando. Por exemplo: &lt;code&gt;instagram.md&lt;/code&gt;. Este documento é onde você vai escrever o conteúdo da sua descrição arquitetural. Veja um exemplo de markdown que eu gerei (&lt;a href=&#34;https://github.com/joaoarthurbm/arqsoft-blog/blob/master/content/posts/documento-guia.md&#34;&gt;link&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;um diretório com o mesmo nome que você deu ao markdown (exceto pela extensão). No exemplo que tratei, seria um diretório chamado &lt;code&gt;instagram&lt;/code&gt;. Neste diretório estarão as imagens que você usará no seu documento (as que são referenciadas no markdown).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Verifique se o seu post está bem formatado.&lt;/p&gt;
&lt;p&gt;2.1 Vá para a raiz do projeto.&lt;/p&gt;
&lt;p&gt;2.2 execute &lt;code&gt;hugo server&lt;/code&gt; ou &lt;code&gt;docker compose up -d&lt;/code&gt;. A versão do hugo que uso é a v0.75.1.&lt;/p&gt;
&lt;p&gt;2.3 Verifique o seu post em &lt;code&gt;http://localhost:1313/arqsoft-blog/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Observe que agora você pode mudar o markdown e ver o resultado sempre. O hugo fica monitorando atualizações nos arquivos e atualiza sempre que um arquivo for modificado.&lt;/p&gt;
&lt;h1 id=&#34;como-entregar&#34;&gt;Como entregar?&lt;/h1&gt;
&lt;p&gt;Simples. Faça um Pull Request do markdown e do diretório de figuras que você criou. Eu revisarei e, assim que for aceito, seu post estará publicado em &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog&#34;&gt;https://joaoarthurbm.github.io/arqsoft-blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Importante.&lt;/strong&gt; Faça apenas um Pull Request com todo o conteúdo do seu post.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para a plataforma freeCodeCamp</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/free-code-camp/</link>
       <pubDate>Tue, 29 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/free-code-camp/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Arthur Silva Lima Guedes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110410&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:arthur.guedes@ccc.ufcg.edu.br&#34;&gt;arthur.guedes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/freeCodeCamp/freeCodeCamp&#34;&gt;https://github.com/freeCodeCamp/freeCodeCamp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----freecodecamp&#34;&gt;Descrição Arquitetural &amp;ndash; freeCodeCamp&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura da plataforma &lt;a href=&#34;https://github.com/freeCodeCamp/freeCodeCamp&#34;&gt;freeCodeCamp&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que o foco nessa descrição são os módulos &lt;em&gt;api-server&lt;/em&gt;, &lt;em&gt;client&lt;/em&gt; e parte do módulo &lt;em&gt;tools&lt;/em&gt;, mais especificamente o &lt;em&gt;search-index&lt;/em&gt;, do repositório acima.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-freecodecamp&#34;&gt;Descrição Geral sobre o freeCodeCamp&lt;/h2&gt;
&lt;p&gt;freeCodeCamp é uma comunidade sem fins lucrativos com o propósito de ajudar no processo de aprendizagem de desenvolvimento de software. Através de uma plataforma web de aprendizagem interativa (e outros meios como fóruns e posts), milhares de pessoas tem a oportunidade de aprender sobre desenvolvimento web, análise de dados, &lt;em&gt;machine learning&lt;/em&gt;, entre diversos outros assuntos, tudo isso de forma 100% gratuita. Algumas respostas para perguntas frequentes podem ser encontradas &lt;a href=&#34;https://www.freecodecamp.org/news/about/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;a-plataforma-de-freecodecamp&#34;&gt;A plataforma de freeCodeCamp&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar uma plataforma de aprendizagem interativa que torne acessível aos usuários assuntos das mais diversas áreas da computação.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;É de extremo interesse acompanhar o progresso do aluno em relação ao &lt;em&gt;curriculum&lt;/em&gt; (similar a um guia de conteúdos), o quanto o mesmo está progredindo nas lições e nos desafios.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de contexto do sistema. Nele, temos um usuário que, em nosso contexto, é descrito como o estudante (ou potencial estudante) da área de programação. A plataforma freeCodeCamp usa o AWS SES (um dos sistemas externos) para o envio de emails para os estudantes, além de um sistema de pagamentos (o PayPal) para os usuários que desejam realizar doações para ajudar a comunidade.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;contexto.png&#34; alt=&#34;Diagrama de contexto - freeCodeCamp&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para a plataforma freeCodeCamp:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;Diagrama de container - freeCodeCamp&#34;&gt;&lt;/p&gt;
&lt;p&gt;A partir da imagem acima, infere-se que o container &lt;strong&gt;freeCodeCamp-Client&lt;/strong&gt; (parte da aplicação que é executada no lado do cliente; o frontend) é acessado diretamente pelo usuário do sistema. O container &lt;strong&gt;API-Server&lt;/strong&gt; expõe uma &lt;em&gt;API REST&lt;/em&gt; que será usada pelo &lt;em&gt;client&lt;/em&gt; para ter acesso a toda parte executada no servidor. A API ainda usa um banco de dados NoSQL, para operações de escrita e leitura (em relação aos schemas). Abaixo, tem-se uma descrição mais detalhada dos containers explicitados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;freeCodeCamp-Client: Nesse container, são executadas funções solicitadas pelo cliente. É responsável também por lidar com os eventos desencadeados pelas ações do usuário. Além disso, renderiza os componentes que, juntos, constroem as páginas da plataforma e fornecem para o usuário um ambiente interativo e prático. Comunica-se com a API usando o protocolo &lt;em&gt;HTTP&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;API-Server: Container que engloba toda a parte do servidor da aplicação. Define os models, rotinas de inicialização do sistema, templates para emails, etc. Além disso, preocupa-se com a lógica de aspectos como autenticação (usando &lt;em&gt;OAuth&lt;/em&gt;) e doações. Como dito acima, esse container fornece uma API REST para ser, consequentemente, consumida pelo container do Client.&lt;/li&gt;
&lt;li&gt;search-indexing: Container responsável por fazer o &lt;em&gt;fetch&lt;/em&gt; de dados como &lt;em&gt;challenges&lt;/em&gt;, &lt;em&gt;posts&lt;/em&gt; da comunidade e &lt;em&gt;playlists&lt;/em&gt; do YouTube. Expõe uma API REST que é usada pelo container da API-Server, o qual manipula de fato os dados extraídos.&lt;/li&gt;
&lt;li&gt;Database: Container que provê um armazenamento para os dados do sistema, como as informações dos usuários. A aplicação usa o &lt;em&gt;Compose&lt;/em&gt;, uma plataforma &lt;em&gt;cloud database&lt;/em&gt;, que torna o gerenciamento da DB mais prático e fácil. O banco de dados usado aqui é o Mongo, um banco de dados não relacional (NoSQL). O MongoDB no compose é oferecido através do serviço de &lt;em&gt;cloud&lt;/em&gt; da IBM.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sobre a implantação do sistema, os containers freeCodeCamp-Client, API-Server e search-indexing traduzem-se em máquinas virtuais na núvem, providas pela plataforma Azure. Detalhes dos pipelines de testes de aceitação e CI podem ser vistos com mais detalhes através dos seguintes links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.azure.com/freeCodeCamp-org/freeCodeCamp/_build&#34;&gt;Azure DevOps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/github/freeCodeCamp/freeCodeCamp/branches&#34;&gt;Travis CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;Diagrama de componentes - freeCodeCamp&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama, tem-se a expansão de três containers do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No freeCodeCamp-Client, temos um componente responsável por renderizar os dados que formam as páginas, o Renderizador, além do Controlador de Pesquisa, responsável por implementar uma lógica para pesquisa de posts a partir do que foi digitado pelo usuário no campo de busca;&lt;/li&gt;
&lt;li&gt;No container API-Server, tem-se diversos componentes:
&lt;ul&gt;
&lt;li&gt;Inicializador de Sessão e Controlador de Autenticação: os componentes responsáveis pelo &lt;em&gt;Sign in&lt;/em&gt; do usuário no sistema. Como descrito no diagrama, os usuários são aptos, caso não queiram fazer um cadastro completo, a acessarem a plataforma usando suas contas do Google, por exemplo (OAuth). O controlador de autenticação é responsável por realizar as verificações dos dados fornecidos pelos usuários;&lt;/li&gt;
&lt;li&gt;Buscador do Currículo: componente responsável por buscar o guia de conteúdos da plataforma (currículo, como é chamado);&lt;/li&gt;
&lt;li&gt;Extrator de Challenges: componente que extrai os challenges propostos no currículo;&lt;/li&gt;
&lt;li&gt;Gerador de Certificado: componente que gera o certificado do usuário após o mesmo concluir os desafios propostos em determinado módulo do curso;&lt;/li&gt;
&lt;li&gt;Controlador de Doações: componente que comunica-se com o sistema externo explicitado para que os usuários possam fazer doações, caso desejem;&lt;/li&gt;
&lt;li&gt;Controlador de envio de emails: Componente que, usando um serviço externo, implementa a lógica para envio dos emails da plataforma;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;O container search-indexing possui componentes que, em síntese, funcionam como um &lt;em&gt;fetcher&lt;/em&gt;, responsáveis por buscar os dados do canal do YouTube, guias de lições, posts e challenges;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;As lições, juntamente com os desafios que as acompanham, são parte fundamental da aplicação. A partir dessas que os usuários podem ter uma ideia de como estão se saindo no curso e como está a curva de aprendizado. Abaixo, temos uma descrição textual e um diagrama que representa os estados dessa informação.&lt;/p&gt;
&lt;p&gt;Após a lição ser postada, ela pode ser selecionada pelo usuário e então, entra em um estado de resolução. Quando o usuário julga que conseguiu resolver o desafio proposto, ele solicita a execução dos testes automáticos, o que leva a lição para um estado de teste. Se o teste falha, o usuário entende que precisa rever a resolução e tentar uma nova abordagem, ou seja, a lição volta para o estado de resolução. Caso a resolução passe pelos testes, a lição é marcada automaticamente como concluída.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;Máquina de estados - freeCodeCamp&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural - Beats</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/beats/</link>
       <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/beats/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento tem por finalidade descrever a plataforma &lt;a href=&#34;https://www.elastic.co/pt/beats/&#34;&gt;&lt;em&gt;Beats&lt;/em&gt;&lt;/a&gt; sob diversos níveis (visões) arquiteturais. Em verdade, &lt;em&gt;Beats&lt;/em&gt; descreve um conjunto de serviços ou &lt;em&gt;agentes&lt;/em&gt; para exportação de dados em alta escala de fontes heterogêneas.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Emanuel Joívo Bezerra Martins.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116110919&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:emanuel.martins@ccc.ufcg.edu.br&#34;&gt;emanuel.martins@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/elastic/beats&#34;&gt;https://github.com/elastic/beats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----data-shippers&#34;&gt;Descrição Arquitetural &amp;ndash; Data shippers&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura da plataforma &lt;a href=&#34;https://www.elastic.co/pt/beats/&#34;&gt;&lt;em&gt;Beats&lt;/em&gt;&lt;/a&gt;, atentando o olhar nos core &lt;a href=&#34;https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html&#34;&gt;&lt;em&gt;shippers&lt;/em&gt;&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-beats&#34;&gt;Descrição Geral sobre o Beats&lt;/h2&gt;
&lt;p&gt;O Beats é uma plataforma que tem como objetivo &amp;ldquo;capturar todo tipo de dado operacional tais quais logs, métricas ou dados de pacote de rede&amp;rdquo; e assim criar um workflow padronizado de envio para plaformas de agregação e indexação de dados como, respectivamente, o &lt;a href=&#34;https://www.elastic.co/pt/logstash&#34;&gt;&lt;em&gt;logstash&lt;/em&gt;&lt;/a&gt; e o &lt;a href=&#34;https://www.elastic.co/pt/what-is/elasticsearch&#34;&gt;&lt;em&gt;elasticsearch&lt;/em&gt;&lt;/a&gt; podendo, posteriormente, obter uma visualização de tais dados via um dashboard como o &lt;a href=&#34;https://www.elastic.co/pt/kibana&#34;&gt;&lt;em&gt;kibana&lt;/em&gt;&lt;/a&gt;. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://github.com/elastic/beats&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;data-shippers---agentes-de-dados-de-finalidade-única&#34;&gt;Data shippers - Agentes de dados de finalidade única&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementação de uma plataforma para coleta e envio automáticos de dados a partir de fontes de dados específicas e heterogêneas. Tais dados são comumente gerados por outros sistemas, ou seja, são dados operacionais tais quais logs, métricas, informações de tráfego de rede, eventos de sistema etc.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A intenção parece ser a de abstrair a extração de dados através de agentes com interfaces padronizadas para a coleta de dados de sistemas heterogêneos e envio desses em larga escala para plataformas de agregação tais quais o logstash e o elasticsearch para análise e pesquisa centralizada e simplificada.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Em linhas gerais, esse sistema pretende estruturar uma plataforma para coleta e envio de dados de fontes específicas tais quais métricas de sistemas e serviços, eventos, logs, etc. O core do sistema está no componente libbeat que descreve uma interface de mais alto nível os quais os &lt;em&gt;beats&lt;/em&gt; têm de satisfazer, além de prover canais de comunicação e protocolos de recuperação de falha na troca de mensagens. Por essa arquitetura quase como um Lego, ou &lt;em&gt;building blocks&lt;/em&gt; novos &lt;em&gt;Data Shippers&lt;/em&gt; podem ser criados ou os existentes customizados, tendo em vista que é um projeto Open Source, de modo a satisfazer um caso de uso não esperado pelos &lt;em&gt;Data Shippers&lt;/em&gt; core. Todo o input do sistema é gerado através das coletas dos dados via os &lt;em&gt;beats&lt;/em&gt;, enviados para a libbeat que por sua vez redireciona tanto para o logstash quanto para o elasticsearch, no segundo caso, ficando assim disponível para consulta/buscas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Cada Beat é simplesmente um binário Go que é instalado no servidor alvo de onde se quer exportar dados. Por exemplo,o &lt;a href=&#34;https://www.elastic.co/beats/winlogbeat&#34;&gt;WinlogBeat&lt;/a&gt;, &lt;em&gt;Shipper&lt;/em&gt; que coleta logs de eventos de sistemas Microsoft Windows precisa estar instalado no server. Cada Beat se comunica com um cluster Elasticsearch e/ou Logstash para exportação dos dados e, por conseguinte, a visualização dos mesmos via chamadas HTTP/REST como segue no diagrama abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para esta sessão, escolheu-se o &lt;em&gt;zoom&lt;/em&gt; em um Beat em específico para detalhamento de seus componentes internos. Filebeat é um &lt;em&gt;shipper&lt;/em&gt; para coleta e exportação de logs de sistema ou de serviços.
Segue abaixo diagrama de componente do Filebeat.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Retomando o caso do Filebeat, a informação em questão são logs produzidos por sistemas e/ou serviços.
Após a especificação dos arquivos de logs no Input, o Filebeat vai manter seus Harvesters assistindo a mudanças nos arquivos e coletando as atualizações. Após isso, cada Harvester publica as mudanças no Spooler que por sua vez envia os eventos dos logs em batch numa única transação por vez.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;information.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Exemplo de documento a ser produzido</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/documento-guia/</link>
       <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/documento-guia/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento guia para os alunos de Arquitetura de Software. A ideia é apresentar o modelo de documentação arquitetural que espero que seja produzido por eles. Esse guia foi baseado em um projeto chamado Parlametria, cujos detalhes arquiteturais estão descritos &lt;a href=&#34;https://docs.google.com/document/d/1OGPN7crENY5u9AiR_AE7Cb9rT92T-U-YppZL0m4TT2s/edit?usp=sharing&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;O documento que você, aluno, deve produzir, deve seguir às diretrizes abaixo. Naturalmente, você pode adicionar, remover e alterar o formato, mas minha sugestão é que você mantenha o padrão que estou apresentando, inclusive, a mesma ordem e nomes de seções. Isso facilitará não só a padronização da documentação produzida por vocês.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Arthur Brunet.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 857394857&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.arthur@computacao.ufcg.edu.br&#34;&gt;joao.arthur@computacao.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/analytics-ufcg/parlametria-site&#34;&gt;https://github.com/analytics-ufcg/parlametria-site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-análise-do-twitter&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de análise do twitter&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/analytics-ufcg/parlametria-site&#34;&gt;Parlametria&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do Parlametria. O foco aqui é a descrição de um serviço específico de análise do twitter, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-parlametria&#34;&gt;Descrição Geral sobre o Parlametria&lt;/h2&gt;
&lt;p&gt;O parlametria é um projeto que tem como objetivo &amp;ldquo;permitir o acompanhamento do posicionamento de cada deputado e senador nas votações, quais os seus vínculos e afinidades políticas e econômicas dentro e fora do Legislativo.&amp;rdquo; Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://portal.ufcg.edu.br/ultimas-noticias/1706-plataforma-desenvolvida-na-ufcg-monitora-acoes-do-legislativo-federal.html&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-monitoramento-do-twitter&#34;&gt;O Serviço de monitoramento do twitter&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para capturar automaticamente o que é dito no twitter sobre as proposições que acompanhamos e prover indicadores sobre as publicações para serem usados no parlametria.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos ter acesso ao grau de atividade no twitter de parlamentares e de influenciadores do debate no twitter. Além disso, queremos saber quanto essas pessoas tuítam sobre cada proposição ou tema e a indicadores sobre sua atividade. Para parlamentares também queremos indicadores a partir dos léxicos de discurso desenvolvidos pelos nossos parceiros.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de contexto e um texto curto descrevendo em mais detalhes o contexto do sistema. Isso inclui as fronteiras do sistema, os sistemas/serviços externos com os quais ele se comunica etc.&lt;/p&gt;
&lt;p&gt;Abaixo estão dois exemplos de diagramas de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;parlametria-contexto.png&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de containers e  texto descrevendo os containers. Detalhe no nível que achar necessário, mas é importante saber do que se trata cada container, suas tecnologias, APIs expostas, protocolos, onde são executados/implantados etc. Você pode criar um diagrama de implantação para dar mais detalhes sobre o ambiente em que os containers são implantados e executam. Essa parte de implantação pode ser uma subseção desta seção.&lt;/p&gt;
&lt;p&gt;Importante, se um componente expor, por exemplo, uma API REST. Seria importante descrever os principais serviços. Talvez até com exemplos de payloads (jsons) para os serviços mais importantes. Ver seção endpoints &lt;a href=&#34;https://docs.google.com/document/d/1OGPN7crENY5u9AiR_AE7Cb9rT92T-U-YppZL0m4TT2s/edit?usp=sharing&#34;&gt;deste documento&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Importante, se um container expuser, por exemplo, uma API REST, seria importante descrever os principais serviços. Talvez até com exemplos de payloads (jsons) para os serviços mais importantes. Ver seção endpoints &lt;a href=&#34;https://docs.google.com/document/d/1OGPN7crENY5u9AiR_AE7Cb9rT92T-U-YppZL0m4TT2s/edit?usp=sharing&#34;&gt;deste documento&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Abaixo estão exemplos de diagramas de containers e de implantação.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers.png&#34; alt=&#34;fig3&#34;&gt;
&lt;img src=&#34;parlametria-container.png&#34; alt=&#34;fig4&#34;&gt;
&lt;img src=&#34;c4-implantacao.png&#34; alt=&#34;fig5&#34;&gt;
&lt;img src=&#34;parlametria-implantacao.png&#34; alt=&#34;fig6&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de componentes e texto descrevendo os componentes. Detalhe no nível que achar necessário, mas é importante saber do que se trata cada componente, seus relacionamentos, tecnologias, APIs expostas, protocolos, estilos, padrões etc.&lt;/p&gt;
&lt;p&gt;Abaixo um exemplo de diagrama de componente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes.png&#34; alt=&#34;fig7&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Aqui você deve descrever as informações importantes que são coletadas, manipuladas, armazenadas e distribuídas pelo sistema. Você não precisa descrever todas as informações, somente uma parte que seja essencial para o sistema. Por exemplo, se eu estivesse tratando do instagram, faria algo relacionado aos posts.&lt;/p&gt;
&lt;p&gt;Além da descrição gostaria de ver aqui um diagrama para descrever os estados (ex: máquina de estados) de uma informação de acordo com as ações do sistema.&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Mini-projeto 1</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/monitor-cidadao/</link>
       <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/monitor-cidadao/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Beatriz Bezerra de Souza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110233&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:beatriz.souza@ccc.ufcg.edu.br&#34;&gt;beatriz.souza@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados&#34;&gt;https://github.com/analytics-ufcg/monitor-cidadao-dados&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-predição-de-risco-de-contratos-públicos&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de predição de risco de contratos públicos&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados&#34;&gt;Monitor Cidadão&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do Monitor Cidadão. O foco aqui é a descrição de um serviço específico de predição de risco de contratos públicos.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-monitor-cidadão&#34;&gt;Descrição Geral sobre o Monitor Cidadão&lt;/h2&gt;
&lt;p&gt;O Monitor Cidadão é um projeto que tem como objetivo &amp;ldquo;possibilitar aos cidadãos o acompanhamento dos contratos realizados pelos municípios dos estados da Paraíba e do Rio Grande do Sul&amp;rdquo;. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-predição-de-risco-de-contratos-públicos&#34;&gt;O Serviço de predição de risco de contratos públicos&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para receber dados e realizar predição de risco de contratos públicos para serem usados no Monitor Cidadão.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos ter acesso a dados, provenientes de diferentes fontes, relacionados a contratos públicos. Além disso, queremos estimar o risco associado a contratos públicos. Para nós, o conceito de risco está associado a chance que um contrato possui de ser &lt;em&gt;rescindido&lt;/em&gt;, &lt;em&gt;paralisado&lt;/em&gt;, &lt;em&gt;sustado&lt;/em&gt; ou &lt;em&gt;impedido&lt;/em&gt;. E as características dos contratos são construídas a partir do comportamento passado e dados cadastrais das empresas responsáveis pelos contratos.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Monitor Cidadão é composto por três camadas: dados, back-end, e front-end, como apresentado no diagrama de contexto abaixo.&lt;/p&gt;
&lt;p&gt;A camada de dados recebe dados de serviços externos, trata os dados recebidos, e realiza previsões sobre os riscos associados a contratos. Atualmente, os provedores de dados para o Monitor Cidadão são Sagres, TCE-RS, IBGE, e Tramita.&lt;/p&gt;
&lt;p&gt;O back-end recebe os dados tratados e as previsões e os repassa para o front-end, que exibe as informações em um formato mais compreensível para os usuários.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os containers do Monitor Cidadão. A camada de dados, que contém o serviço de predição que queremos descrever, é composta por cinco componentes: um fetcher, um transformador, um preditor, e dois bancos de dados.&lt;/p&gt;
&lt;p&gt;O fetcher, o transformador, e o preditor são sistemas desenvolvidos em R. Os dois bancos de dados são relacionais, fazem uso do postgres. O fetcher é responsável por buscar os dados em suas fontes. O transformador utiliza o tradutor, um serviço interno responsável por traduzir os dados para um formato tabular, e em seguida realiza manipulações, como joins, nos dados. O preditor encapsula diversas funções para a realização das predições em torno dos contratos públicos.&lt;/p&gt;
&lt;p&gt;Note que acessos aos bancos de dados são realizados por meio de objetos de acesso a dados (DAO).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;implantação&#34;&gt;Implantação&lt;/h4&gt;
&lt;p&gt;O diagrama abaixo mostra onde os containers do Monitor Cidadão estão implantados. As fontes de dados são serviços externos. O banco de dados SAGRES está implantado em uma máquina virtual chamada data-lake-mc. Os demais componentes estão implantados em outra máquina virtual chamada monitor-cidadão.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;implantacao.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os componentes do preditor do Monitor Cidadão: um gerador de features, um seletor de features, um pré-processador, um treinador e um avaliador. Todos estes componentes são desenvolvidos em R.&lt;/p&gt;
&lt;p&gt;O gerador de features recebe dados do AL_DB e cria novas features com base em manipulações dos dados existentes. O seletor de features seleciona as features mais recentemente adicionadas no banco de dados MC_DB. O pré-processador recebe as features selecionadas e realiza pré-processamento nos dados: divide os dados em treino e teste e realiza conversões de tipo. O treinador é responsável por treinar modelos do tipo regressão logística e floresta aleatória. O avaliador calcula métricas para os modelos treinados.&lt;/p&gt;
&lt;p&gt;Note que as informações referentes à predição: conjunto de features utilizadas, modelos, métricas, são salvos no MC_DB. Acessos aos bancos de dados são realizados por meio de objetos de acesso a dados (DAO).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo descreve a máquina de estados dos dados do preditor do Monitor Cidadão. Se formos gerar novas features, saímos do estado inicial (1) para o estado (2), onde os dados estão armazenados no AL_DB. Então executamos o DAO e vamos para o estado (3), onde os dados foram carregados para manipulação. Depois, executamos o gerador de features e vamos para o estado (4), onde temos os dados com as novas features. Executamos o DAO e vamos para o estado (5), onde as features foram armazenadas no MC_DB. Se não formos gerar novas features, saímos do estado inicial (1) para o estado (5), onde as features estão armazenadas no MC_DB.&lt;/p&gt;
&lt;p&gt;Do estado (5), executamos o seletor de features e vamos para o estado (6), onde os dados com as features mais recentes foram escolhidos. Depois, executamos o DAO e vamos para o estado (7), onde os dados para manipulação foram carregados. Então executamos o pré-processador e vamos para o estado (8), onde temos os dados balanceados e com tipos adequados. Em seguida, executamos o treinador e vamos para o estado (9), onde temos os modelos treinados. Executamos o avaliador e vamos para o estado (10), onde temos os modelos avaliados. Por fim, executando o DAO, vamos para o estado (11), que é o estado de aceitação, onde os dados do experimento estão armazenados no MC_DB.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;estados-preditor.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Ao produzir o conteúdo deste post, abri dois PRs para o repositório da camada de dados do Monitor Cidadão. O primeiro PR foi para atualizar o diagrama do fluxo de dados, que se encontra desatualizado no README do repositório. Em 12 de Outubro de 2020, o PR está aberto: &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/73&#34;&gt;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/73&lt;/a&gt;. O segundo PR foi para adicionar um documento de descrição da arquitetura do preditor do Monitor Cidadão de acordo com o modelo C4. Tal documento não existia no projeto. Em 12 de Outubro de 2020, o PR está aberto: &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/74&#34;&gt;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/74&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Moment Js</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/momentjs/</link>
       <pubDate>Thu, 10 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/momentjs/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento explica aspectos da arquitetura de uma das mais conhecidas bibliotecas JavaScript para manipulação de data e hora. O Moment
torna a tarefa de manipulçação de data mais simples para o desenvolvedor.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Paulo Dantas.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211312&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:paulo.dantas@ccc.ufcg.edu.br&#34;&gt;paulo.dantas@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/moment/moment/&#34;&gt;https://github.com/moment/moment/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----moment&#34;&gt;Descrição Arquitetural &amp;ndash; Moment&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/moment/moment/&#34;&gt;Moment&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-moment&#34;&gt;Descrição Geral sobre o Moment&lt;/h2&gt;
&lt;p&gt;O &lt;em&gt;Moment&lt;/em&gt; tem como objetivo disponibilizar ao desenvolvedor ferramentas para a criação e manipulação de datas em projetos JavaScript.
Ele dispõe de um conjunto de funções que tem como objetivo auxiliar o trabalho do desenvolvedor, fazendo com que o trabalho com objetos do tipo Date se torne mais simples.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-manipulação-de-datas-do-moment&#34;&gt;O Serviço de manipulação de datas do Moment&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Criar objetos do tipo Date que são facilmente convertidos, formatados e manipulados. Proporcionando, deste modo, que o desenvolvedor escreva códigos mais simples e concisos.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Auxiliar no desenvolvimento de projetos que manipulam datas, a partir da criação de objetos mutáveis que são simples de serem trabalhados.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O &lt;em&gt;Moment&lt;/em&gt; é um pacote que possui diversas ferramentas para manipulação de datas. Tornando mais simples a construção de datas e a sua conversão para diferentes formatos. Deste modo, ele não utiliza nenhuma API externa, fazendo utilização apenas do sistema operacional na qual está sendo utilizado.&lt;/p&gt;
&lt;p&gt;Na criação de um objeto moment, o construtor extrai a data do sistema operacional na qual está inserido. Deste modo, permite a utilização do moment em sistemas offline e em qualquer plataforma.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-context-diagram.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A principal funcionalidade do Moment Js é a criação e manipulação de datas, mas, além disso, ele também apresenta um módulo para internacionalização e um módulo que é responsável pela criação de objetos de duração, que são representantes de períodos de tempo. Tais containers são mostrados no diagrama de container abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-container-diagram.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;analisador-de-objetos-de-data-e-hora&#34;&gt;Analisador de objetos de data e hora&lt;/h5&gt;
&lt;p&gt;O container analisador de objetos de data e hora é responsável por criar um objeto que empacota uma data. Além disso, ele possui diversas ferramentas para incrementar, decrementar ou converter este objeto, tendo em vista que estes objetos do moment são mutáveis.&lt;/p&gt;
&lt;h5 id=&#34;i18n&#34;&gt;i18n&lt;/h5&gt;
&lt;p&gt;O container de internacionalização é responsável por configurar o ambiente para a qual o moment será utilizado. Com ele é possível estabelecer qual a localização geográfica do sistema e o idioma default utilizado, além de permitir a visualização de meses e dias da semana no idioma estabelecido.&lt;/p&gt;
&lt;h5 id=&#34;analisador-de-objetos-de-duração&#34;&gt;Analisador de objetos de duração&lt;/h5&gt;
&lt;p&gt;Já o container representante da análise de objetos do tipo duração possui a função de criar objetos que representam períodos de tempo. Com eles é possível realizar conversões entre diferentes unidades de tempo (exemplo: minutos, segundos, horas) e manipular estes objetos.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O principal container do moment é o de análise de objetos de data e hora, por este motivo ele terá um foco maior e seus componentes estão representados na imagem abaixo. Neste container é onde ocorre a criação dos objetos de data e a manipulação dos mesmos. O container de análise de data é composto por 5 módulos, são eles: Parser, Get and Set, Manipulate, Display e Compare. Estes serão descritos a seguir.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-component-diagram.png&#34; alt=&#34;componente&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;parser&#34;&gt;Parser&lt;/h5&gt;
&lt;p&gt;O componente de Parser é responsável por criar os objetos que representam data e hora. A partir dele que os métodos de manipulação e conversão são disponibilizados.&lt;/p&gt;
&lt;h5 id=&#34;get-and-set&#34;&gt;Get and Set&lt;/h5&gt;
&lt;p&gt;O componente Get and Set é composto por um conjunto de métodos que possibilita a modificação e obtenção de parâmetros pontuais de um objeto. Por exemplo, é através deste componente que pode-se modificar data ou hora de um objeto moment, assim como obter essas informações do mesmo objeto.&lt;/p&gt;
&lt;h5 id=&#34;manipulate&#34;&gt;Manipulate&lt;/h5&gt;
&lt;p&gt;Semelhante ao componente de Get and Set, o componente Manipulate também é responsável por realizar modificações em objetos criados pelo Parser. A diferença é que os métodos disponibilizados pelo Manipulate não realizam modificações nos objetos de forma direta. O Manipulate pode adicionar ou remover horas, minutos, dias, meses, de forma muito mais prática. O desenvolvedor pode deixar a cargo do componente o cálculo de conversão de data ao ser retirado 1 mês, por exemplo, do dia informado.&lt;/p&gt;
&lt;h5 id=&#34;display&#34;&gt;Display&lt;/h5&gt;
&lt;p&gt;O componente Display é responsável pelas conversões dos objetos moment para diferentes formatos, como por exemplo: String, JSON, Date, dentre outros. Com ele o moment pode converter seus objetos para o formato Date, para assim serem salvos em um banco de dados. Além disso, pode converter datas para o formato String, para ser apresentado ao usuário.&lt;/p&gt;
&lt;h5 id=&#34;compare&#34;&gt;Compare&lt;/h5&gt;
&lt;p&gt;Por fim, o componente Compare é responsável por fazer comparações entre diferentes datas. Assim, ele disponibiliza mecanismos para informar se uma data está a frente de outra e se duas datas, construídas a partir de diferentes formatos, são iguais. Além disso, é com esse componente que é possível verificar se uma String pode ser utilizada para construir um objeto moment.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como mencionado anteriormente os objetos de data moment são mutáveis, e é este princípio que o diagrama de estados abaixo apresenta.
Inicialmente o objeto moment recebe como parâmetro uma String ou uma data, e a partir deste ponto ele se encontra em estado de análise.
Logo após a análise dos parâmetros o moment vai decidir se os parâmetros informados podem representar uma data, se sim o objeto vai para o estado de criado, caso contrário ele se torna inválido e não poderá mais ser utilizado.
Com o objeto em estado de criado ele pode ser modificado, através dos componentes Setter, Compare e Manipulate. Neste ponto ele se encontra no estado de &amp;ldquo;Em modificação&amp;rdquo;, caso os parâmetros informados para a sua modificação sejam válidos ele retorna para o estado de Criado e estará disponível para utilização futura, caso contrário ele se tornará inválido e sua vida útil irá acabar.
Por fim este objeto pode ser formatado, a partir do componente Display, e assim convertido para um objeto do tipo String ou Date, acabando, deste modo, sua vida como objeto moment.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-visao-informacao.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
 </channel>
</rss>
